System  /*  -trace */ parkingarea		
Event outsonar : outsonar (O)
Dispatch sonar : sonar(G)
Dispatch outfree : outfree(free)
Event alarm : alarm(W)

Event weightsensor : weightsensor(W)
Dispatch weight : weight (W)

Dispatch trolleycmd : trolleycmd(MOVETO)
Dispatch cmd       	: cmd(M)     
Dispatch trolleyEnd : end(V)   
Dispatch position : pos(P)   

Request carenter : carenter(C)
Reply receipt : receipt(I)  


Request notifyIn : notifyIn(N)  
Reply informIn : informIn(S)

Request pickup : pickup(TOKENID)
Reply ok : ok(O)

Dispatch end : end(e)

Event takecar : takecar(P)   

Dispatch obstacle  : obstacle( ARG ) 		//generated by distancefilter
Event  endall	   : endall( ARG )    
Event   info       : info( ARG ) 	    	//for external components, not coap-observed
Event  sonar       : sonar(DISTANCE,NAME)	//emitted by distancefilter

Dispatch end       	: end(ARG)   
   
Dispatch moveok	: move( MOVESHORT )
Request step	: step( TIME )	 
Reply   stepdone	: stepdone(V)  
Reply   stepfail	: stepfail(DURATION, CAUSE)

Dispatch fanstart: fanstart(V)
Dispatch fanstop : fanstop(V) 

Dispatch temp : temp(V) 

Event temperature: temperature(T) 

 
Context ctxparkingarea ip [host="localhost" port=8021]  

CodedQActor datacleaner    context ctxparkingarea className "rx.dataCleaner"  //NOT used with the virtualrobot
CodedQActor distancefilter context ctxparkingarea className "rx.distanceFilter"

QActor outsonar context ctxparkingarea{
	
 	State s0 initial {
 		discardMsg On
		println("outsonar | start")
	
	} Goto work
	
	State work{
		println("outsonar | work")
	}Transition t0 whenMsg sonar ->handlemsg
	
	State handlemsg{
		printCurrentMessage
		[#			
			var DIST=0
		#]
		println("outsonar | handlemsg")
		onMsg( sonar : sonar(O) ){
			[# DIST = payloadArg(0).toInt() #] 		
			if[#DIST<20 #]{
				emit outsonar : outsonar (O)
			}else{ 
				emit takecar : takecar(P)
			}
		}
		
	} Goto work
}

QActor outmanager context ctxparkingarea{
	[#	var start =  0L
		var difference = 0L
	#]
	State s0 initial{
		
		println ("outmanager | start")
		
	} Transition t0 whenEvent 	outsonar -> start
	
	State start{
		
		[# start = System.currentTimeMillis()#]
		println("outmanager [start] | start Timer ) ")
		forward parkmanagerservice -m outfree : outfree(occ)
		 
	}Goto work
		
	State work{
		
		[#difference = System.currentTimeMillis() - start#]
		//println("outmanager [work] |  difference = $difference")
		if[#difference >= 10000L#]{
			println("outmanager [work]  | alarm event, time passed = $difference")
			emit alarm :alarm(a)
		}

	} Transition t0 whenTime 300 ->work
					whenEvent takecar-> free
								
	State free {
		forward parkmanagerservice -m outfree : outfree(free)
		println("outmanager[free] | OUTDOORAREA FREE")
	}
	Transition t0 whenEvent 	outsonar -> start
}


QActor weightsensor context ctxparkingarea{
	
	State s0 initial {
		discardMsg On
		println("weightsensor | start")
			
	}Goto working 
	
	 State working {
		println("weightsensor | working")
	}  Transition t0 whenMsg weight ->handleweight
	
	State handleweight{
		delay 1000
		println("weightsensor | work")
		onMsg( weight : weight(W) ){
			[# var WEIGHT = payloadArg(0).toInt() #] 
			
			updateResource[#"weightsensor($WEIGHT)"#]
			
			println ("weightsensor [work] | weight car: $WEIGHT")
			emit weightsensor : weightsensor ($WEIGHT)
			println("weightsensor [work] | emit event")

		}	
	}Goto working
}

QActor parkmanagerservice context ctxparkingarea {
	
	[# 	var SLOTNUM = 0
		var CARSLOTNUM = 0 
		var TOKENID = " "
		var INFREE =1
		var OUTFREE = 1
		var stateTrolley =1
	#]
	
	State s0  initial{
		println("parkmanagerservice | start")
	} 
	Goto working 
	
	State working {
		println("parkmanagerservice | working")
	} 
	Transition t0 	whenRequest notifyIn -> acceptIn
					whenRequest pickup -> acceptOut
					whenRequest carenter -> handleCarenter
					whenEvent 	weightsensor -> handlemsgIn
					whenMsg 	outfree -> handlemsgOut
					whenMsg  	end -> theend	
					whenEvent   alarm-> handlealarm
	State handlealarm{
		
		updateResource[#"alarm(a)"#]
		println ("parkManagerService [handlealarm] | alarm")
		
	}Goto working 
	State handlemsgIn{
		printCurrentMessage
		onMsg(weightsensor: weightsensor(W)){
		[# var W = payloadArg(0).toInt() #] 
		
				if[#W>0#]{
					[#INFREE = 0 #]
					println("parkManagerService [handlemsgIn] | INDOOR occupied")
		
				}else {[#INFREE = 1#]
					println("parkManagerService [handlemsgIn] | INDOOR free")
				}
		}
	}Goto working
	
	State handlemsgOut{

		onMsg(outfree: outfree(W)){
			[# var O = payloadArg(0) #] 
			
				if[#O.equals("occ")#]{
				[#OUTFREE = 0 #]
				println("parkManagerService [handlemsgOut] | OUTDOOR occupied")
				}
				if[#O.equals("free")#] {[#OUTFREE = 1#]
				println("parkManagerService [handlemsgOut] | OUTDOOR free")
				}
		}
	
	}Goto working
					
	State acceptIn{
		println("parkManagerService | acceptIn") 
		updateResource [#"parkmanagerservice(acceptIn)"#]	
		onMsg(notifyIn: notifyIn(N)){
			println("$INFREE")
			if	[# INFREE ==1 && stateTrolley == 1#]{
					[# SLOTNUM = Slotnum.getSlotnum() #]
					replyTo notifyIn with informIn : informIn($SLOTNUM)
			}
			else {
				replyTo notifyIn with informIn : informIn(9)
				
				println("parkManagerService [acceptIn] | indoor-area occupied, the request could not be processed")
			}
		}
	} 
	Transition t0	whenRequest carenter -> handleCarenter
				 	whenRequest pickup -> acceptOut
					whenRequest notifyIn -> acceptIn
	State handleCarenter{
		updateResource [# "parkmanagerservice(handleCarEnter)" #]	
		println("parkManagerService | caraenter")
		onMsg(carenter : carenter(S)){
			[#   
	 			SLOTNUM= payloadArg(0).toInt()
			#]
	
			if  [# SLOTNUM!= 0 #]{ 
				println("parkManagerService [carenter] | send to trolley moveToIn")
			[# var SLOTFREE = Slotnum.slotfree(SLOTNUM)#]
								println("parkManagerService [carenter] | $SLOTFREE")
			
				if[#Slotnum.slotfree(SLOTNUM)#]{
					
					[#Slotnum.uptadeSlotnum(SLOTNUM, false)#]
					forward trolley -m trolleycmd : trolleycmd(moveToIn)
				//TODO check that the trolley has taken the car with the weightsensor
					delay 200			
					//if[#INFREE == 0#]{//non so se serve 
						[# 
						var MOVETOSLOT = "moveToSlot".plus(SLOTNUM)
						#]
						println("parkManagerService [carenter] | send to trolley $MOVETOSLOT")
						forward trolley -m trolleycmd : trolleycmd($MOVETOSLOT)
				
						[# TOKENID=  Slotnum.generateTOKENID(SLOTNUM) #]
				
						println("parkManagerService [carenter] | send to client TOOKENID = $TOKENID")
						replyTo carenter with receipt : receipt($TOKENID)
						//}
				}else {
					if[#INFREE == 0#]{
					println("parkManagerService [carenter] |l'indoor area Ã¨ occupata ")
					
					replyTo carenter with receipt : receipt(8)
					forward trolley -m trolleycmd : trolleycmd(moveToHome)
					
					}else {
						replyTo carenter with receipt : receipt(9)
						
					}

				}
			}else{
				replyTo carenter with receipt : receipt(0)

				forward trolley -m trolleycmd : trolleycmd(moveToHome)

			}   
		}
	} Transition t0	whenRequest carenter -> handleCarenter
				 	whenRequest pickup -> acceptOut
					whenRequest notifyIn -> acceptIn
	 
	State acceptOut{
		updateResource [#"parkmanagerservice(acceptOut)"#]
		println("parkManagerService | acceptOut ")
		if[#OUTFREE == 1 && stateTrolley == 1#]{ 
			onMsg(pickup : pickup(TOKENID)){ 
				
				[#TOKENID= payloadArg(0).toString() #]
				println("parkManagerService [acceptOut] | receive TOKENID = $TOKENID")
				
				[# CARSLOTNUM = Slotnum.findSlot(TOKENID) #]
				println("parkManagerService [acceptOut]]: receive CARSLOTNUM = $CARSLOTNUM")
				replyTo pickup with ok : ok($OUTFREE)
				[#
					Slotnum.uptadeSlotnum(CARSLOTNUM, true)
					var MOVETOSLOT = "moveToSlot".plus(CARSLOTNUM)
				#]
				forward trolley -m trolleycmd : trolleycmd($MOVETOSLOT)
				forward trolley -m trolleycmd :trolleycmd(moveToOut)
			}
		}else{
			replyTo pickup with ok : ok($OUTFREE)
			println("parkManagerService [acceptOut]: outdoor-area occupied, the request could not be processed")
		}
	}
	Goto working
	
		State theend{
		
		forward trolley -m trolleycmd : trolleycmd(end)

	}
		
}


QActor trolley context ctxparkingarea{
[#  val mapname     = "parkingMap0"  		  
  var Myself      = myself     
  var CurrentPlannedMove = ""   
  var MOVE = ""
  var terminate =  0
  var home = 0
  var counter = 0
  var trolleyCmd = ""
  var listCommand = arrayListOf<String>()
  
#]   	
	State s0 initial{
		println ("trolley | start ")
		[#TrolleyPlannerSupport.initPlanner("$mapname")#]
 
	}
	Goto idle
	           
	State idle{
		println("trolley [idle]  | waiting......... ") 
	  
	} 	
	
	Transition t1  	 whenMsg     trolleycmd  -> working
													
	State working{
		
		println("trolley | working")
		[#home = 0#] 
		onMsg( trolleycmd : trolleycmd(V) ){
			[#	trolleyCmd = "${payloadArg(0)}" 	 
				TrolleyPlannerSupport.setGoal(trolleyCmd)
				if(trolleyCmd == "moveToHome"){
					home =  1
				}
				if(trolleyCmd == "end"){
					terminate =  1
				}
			#]
		}
	} 
	
	Goto execPlannedMoves 
		
  	State execPlannedMoves{
  		delay 400
 		[#CurrentPlannedMove = TrolleyPlannerSupport.getNextMove() #]
	}
	Goto doMove if [# CurrentPlannedMove.length>0  #] else finishPlannedMoves 
	
	State doMove{ 		
		forward basicrobot -m cmd : cmd($CurrentPlannedMove)
  	} 
  
	Transition t1   whenTime 100 -> execPlannedMoves
 					whenMsg  trolleycmd  and [#home == 1 && terminate == 0#]-> working
 	
 	State finishPlannedMoves{  
 		println("trolley | finishPlannedMoves")
 	
 		[#if(home == 1 || terminate == 1){
 		
 			listCommand =  TrolleyPlannerSupport.atHome()
			for (command in listCommand) {   
   				forward("cmd", "cmd(${command})" ,"basicrobot" )
			}
		}else{ 
			listCommand =  TrolleyPlannerSupport.loadUnloadCar()
			for (command in listCommand) {
   				forward("cmd", "cmd(${command})" ,"basicrobot" )
			}
				delay(1000)//we want to simulate load/unload the car
		}#]    
		updateResource[#TrolleyPlannerSupport.getPosition()#]
		
	
 	}	
	Goto endWork if [# terminate == 1  #] else idle
	  
	State endWork{
		println("trolley |  endWork")
		forward basicrobot -m end : end(V)         
	}					
}

QActor basicrobot context ctxparkingarea{
	[#
	  var StepTime      = 0L 
	  var StartTime     = 0L     
	  var Duration      = 0L  
	  var RobotType     = "" 
	  var CurrentMove   = "moveUnknown"
	#]     
	State s0 initial {     
		println("basicrobot | START")	 
 		//[# sysUtil.trace = true #]		//Equivalent to the -trace flag
 		 
 		[# sysUtil.waitUser("hello", 3000) #]
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		[# RobotType = unibo.robot.robotSupport.robotKind #]
        if[# RobotType != "virtual" #]{
	 		println("basicrobot | type=$RobotType attempts to activate the sonar pipe")	
	 		[#  //For real robots
				//delay( 1500 ) //give to the realsonar the time to start
	 			var robotsonar = context!!.hasActor("realsonar")  
	 			if( robotsonar != null ){ 
	 				println("basicrobot | WORKING WITH SONARS") 
	 				//ACTIVATE THE DATA SOURCE realsonar
	 				forward("sonarstart", "sonarstart(1)" ,"realsonar" ) 				
	 				//SET THE PIPE  
	 				robotsonar.
	 				subscribeLocalActor("datacleaner").
	 				subscribeLocalActor("distancefilter").
	 				subscribeLocalActor("basicrobot")		//in order to perceive obstacle
	 			}else{
	 				println("basicrobot | WARNING: realsonar NOT FOUND")
	 			}
	 		#]  
 		} 
		else{ //virtual
			[#  var robotsonar = context!!.hasActor("robotsonar") 
	 			if( robotsonar != null ){ 
	 				println("basicrobot | WORKING WITH VIRTUAL SONAR") 
	 				//ACTIVATE THE DATA SOURCE realsonar
	 				forward("sonarstart", "sonarstart(1)" ,"robotsonar" ) 				
	 				//WE DO NOT SET THE PIPE, since we don't have sonar data  to clean
	 				/*
	 				robotsonar.
	 				subscribeLocalActor("datacleaner").
	 				subscribeLocalActor("distancefilter").
	 				subscribeLocalActor("basicrobot")	*/	
	 			}else{
	 				println("basicrobot | WARNING: robotsonar NOT FOUND")
	 			}
 
 			#] 
 		}
 		
	//	updateResource [# "basicrobot(start)" #]
 
		discardMsg Off  //WE want receive any msg 
	} 
	
	Goto work
	 
	State work{  
		println("basicrobot  | waiting .................. ")  
		
	}
	  
	Transition t1   whenMsg    	cmd		-> exec
					whenRequest step	-> doStep			
					whenMsg		obstacle	-> handleObstacle  //in virtualrobot caused by the move w/s
				  	whenMsg    	end	-> endwork			  
	
	
	
	State exec{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){ 
  			//activate the motors  
			[# CurrentMove =  "${payloadArg(0)}" #] 
			println("CurrentMove =  $CurrentMove")
		 	if [# CurrentMove == "w" #] {
				//delay 1000
				run unibo.robot.robotSupport.move( "w" ) 
				delay 400
				run unibo.robot.robotSupport.move( "h" )
			}else{
				run unibo.robot.robotSupport.move( "${payloadArg(0)}" )
			}
			if [# CurrentMove != "h" #] { updateResource [# "moveactivated($CurrentMove)" #] }
		}
	 }  
	 
	Goto work      
	        
	State handleObstacle{   
	    run unibo.robot.robotSupport.move( "h" )
		println("basicrobot | handleObstacle CurrentMove=$CurrentMove")	
		printCurrentMessage
			//msg(obstacle,dispatch,distancefilter,basicrobot,obstacle(5),18)
		if[# CurrentMove == "w" #]{
 			/*
			 * collision Json      : emitted by the virtualrobot 
			 * obstacle(virtual)   : emitted by the virtualrobotSupport2021 when endmove=false
			 * obstacle(5)         : emitted by the distanceFilter
			 * obstacle(w)         : emitted by the basicrobot
			 */ 
		//updateResource [# "obstacle(w)" #]
			//delay 300
			
		//println("COMPENSATEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE")
		run unibo.robot.robotSupport.move( "s" ) 
		delay 100 //loose the control ...
		run unibo.robot.robotSupport.move( "h" ) 
		
			//delay 1000	//give time
 		 
		} 	
	}
	
	Goto work
	
	State handleSonar{
		printCurrentMessage
	}
	
	Goto work
		
   	State doStep{ 
 		printCurrentMessage  
		onMsg( step : step( T ) ){  
			[#	StepTime = payloadArg(0).toLong() 	#]  
			updateResource [# "step(${StepTime})" #]
  		}  
        memoCurrentTime StartTime  
        println("basicrobot | doStep StepTime =$StepTime ")        
        run unibo.robot.robotSupport.move( "w" )  //moves a real robot forever
        
	}  
	Transition t0 	whenTimeVar StepTime  -> stepDone //stepPerhapsDone	//caused by p
					whenMsg  obstacle     -> stepFail		
        //whenMsg     cmd       -> execcmd
  	 
	State stepDone{   
 		run unibo.robot.robotSupport.move( "h" )  //stop the real robot already done
		println("basicrobot | stepDone")
		updateResource [# "stepDone($StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone(ok)
		//println("basicrobot | stepDone reply done")
  	}
	Goto work  
 
	State stepFail{  		
		setDuration Duration from StartTime
		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		[# var TunedDuration = Duration;  
			TunedDuration = Duration * 5 / 6
		#]
		println("basicrobot | stepFail duration=$Duration TunedDuration=$TunedDuration")
			run unibo.robot.robotSupport.move( "s" )
			delayVar TunedDuration 
			run unibo.robot.robotSupport.move( "h" ) 
 		updateResource [# "stepFail($Duration)" #] 
 		//emit info : info( stepFail($Duration) )
 		replyTo step with stepfail : stepfail($Duration, obst)
    }
	Goto work
	
	State endwork{ 
		println("basicrobot | endwork")
		onMsg( end : end( V ) ){ 
			println("basicrobot | endwork")
			updateResource [# "basicrobot(end)" #]	 		
			//run utils.virtualRobotSupportQak.terminatevr( )
		}
 		emit endall : endall(normal) 
 		terminate 1
	}      
 }

QActor fan context ctxparkingarea{    
	State s0 initial {  		
						println("fan | start")
		
	}
	   
	Goto stopped    
	
	State stopped {
		println ("fan | stopped") 

		updateResource [# "{\"info\":\"fan(off)\"}" #] 
		
	}
	
	Transition t0 whenMsg fanstart->working
				  
	State working {
		println("fan | working")
		updateResource [# "{\"info\":\"fan(on)\"}" #] 
	}
	
	Transition t0 whenMsg fanstop->stopped
				
}
	
 QActor thermometer context ctxparkingarea{
 	[# var T= ""#]
		State s0 initial {
			println("thermometer | starting ")
	}Goto work  
	State work{
    println("thermometer | work")
    	
	}Transition t0 whenMsg temp-> handleMsg

State handleMsg{
	onMsg(temp : temp(T)){
    	[# T= payloadArg(0)#]
    	emit temperature : temperature ($T)
    	printCurrentMessage
    	}
	
}Goto work
}



QActor parkingmanager context ctxparkingarea {
	[#var fanIsStarted = 0 
		
	#]
	State s0 initial {
		println("parkingManager | start")
		
	} 
	Goto waiting
	State waiting{
		
		println("parkingManager | waiting")
		
	}
	Transition t0 whenEvent temperature-> handleTemp
	State handleTemp
	{
		println("parkingManager | handleTemp")
		onMsg(temperature : temperature(T)){
			printCurrentMessage
				
			[# var temp= payloadArg(0).toInt()#]
			if[# temp > 35  && fanIsStarted == 0 #]{
				println("parkingManager [handleTemp]: send start command to fan ")
				forward fan -m fanstart: fanstart(on)
				[#fanIsStarted = 1#]
				
			}if[# temp <= 35  && fanIsStarted == 1#] {
				println("parkingManager [handleTemp]: send stop command to fan ")
				forward fan -m fanstop: fanstop(off)
				[#fanIsStarted = 0#]
			}
			}
	}
	Goto waiting
	
	}
 