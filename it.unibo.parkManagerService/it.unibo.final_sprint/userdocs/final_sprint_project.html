<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
	font-family: "Arial";
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
kn{
	font-family: "Arial";
    color: #0000CD	;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
h6 {
    background-color: #d5fff0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
</style>
    
<head>
   
<title>Automated Car-Parking</title></head>
    
<body>
<div id="top">
<h1>Automated Car-Parking<font size="5"></font> </h1>
</div>  

<h2>Requirements</h2>

<div class="remark">
The requirements given by the costumers are <a href="https://github.com/anatali/issLab2021/blob/main/it.unibo.issLabStart/userDocs/TFBO21ISS.pdf" target="web">Automated Car-Parking</a></li>
</div> 
<h5>Last Sprints</h5>
This sprint will be the summary of th lasts sprint that they are focused on the following arguments. 

<ul>
<li><a href="https://htmlpreview.github.io/?https://github.com/noemival/ParkManagerService_2021/blob/main/it.unibo.parkManagerService/it.unibo.sprint1/userdocs/sprint1.1_project.html">Sprint1</a>: realize basic movements of the transport trolley.</li>
<li><a href="https://htmlpreview.github.io/?https://github.com/noemival/ParkManagerService_2021/blob/main/it.unibo.parkManagerService/it.unibo.sprint2/userdocs/sprint2_project.html">Sprint2</a>: realize the interaction between the parkManagerService and client.</li>
<li><a href="https://htmlpreview.github.io/?https://github.com/noemival/ParkManagerService_2021/blob/main/it.unibo.parkManagerService/it.unibo.sprint3/userdocs/sprint3_project.html">Sprint3</a>: realize interaction between the parkManagerService and the sensors.</li>
<li><a href="https://htmlpreview.github.io/?https://github.com/noemival/ParkManagerService_2021/blob/main/it.unibo.parkManagerService/it.unibo.sprint4/userdocs/sprint4._projecthtml">Sprint4</a>: : realize the operations of the parkingManager.
</li>

<h2>Requirement analysis</h2>
	Our interaction with the customer has made it clear what he means for:
<li><kn>parking-area</kn>: an empty room showed in the map, where:
	<table>
		<tbody>
			<tr>
				<td>
					<ul>
						<li> "O" is the OUTDOOR-area;</li>
						<li> "I" is the INDOOR-area ;</li>
						<li> "r" is the home ;</li>
						<li> "X" are the walls; </li> 
						<li> "s" are the slots. </li> 
					</ul>
				</td>
				<td style="width: 50%">

					 <center><img src="./img/parkingArea.png" alt="mappa" width="70%" ></center> 
				</td>
			</tr>
		</tbody>
	</table>
<li><kn>room </kn>: a conventional room of a house;
<li><kn>car </kn>: a conventional car;
<li><kn>home</kn>: an area where the robot is at the beginning and where it goes when it hasn't any requests;</li>
<li><kn>INDOOR-area</kn>: the area in front of the parking INDOOR where is the weightsensor and the trasport trolley loads the car;</li>
<li><kn>OUTDOOR-area</kn>: the area in front of the parking OUTDOOR where is the OUTsonar and the trasport trolley releases the car;</li> 
<li><kn>parking-slots</kn>: number of slots in the parking where the robot parks the car; </li>
<li><kn>weightsensor</kn>: an simulate device capable of detecting the presence of a car and measuring its weight. It is in the INDOOR-area and sends the information taken via the network as event emitter;</li>

<li><kn>thermometer</kn>: an simulate device capable of detects the temperature in the parking-area. It sends the information taken via the network as event emitter;</li>

<li><kn>fan</kn>: a device capable to lower the temperature of the parking. It could be in on/off state and it is possible switch the state with dispatch messages via the network;</li>
<li><kn>SLOTNUM</kn>: unique identifier of a parking-slot;</li>
<li><kn>TOKENID </kn>: unique string assigned to a client when his entrance request was accepted; </li>
<li><kn> client</kn>: an entity who sends messages to the ParkerServiceManager via the network;
<li><kn>CARENTER</kn>: a ParkServiceGui graphic element that allows an user to notify the intention to let the car in;
<li><kn>ParkServiceStatusGUI</kn>: an user interface that allows a parking-manager to comunicate with parkManagerService using graphic representations and that shows the parking-area current state; </li>
<li><kn>current state</kn>: TA temperature, state of the fan (on/off), state of the trasport trolley (idle, working or stopped);
<li><kn>stop</kn>: when the robot isn't in a idle or working state;
<li><kn>alarm</kn>: a message that has been sent by the ParkManagerService to the ParkServiceStatusGUI if the OUTDOOR-area has not been vacated within an interval of time DTFREE;</li>
<li><kn> fixed obstacles </kn>: any fixed element in the parking-aerea which the robot could collide with (e.g. a wall); </li>
<li><kn> request </kn>: a message which was sent by the client to the ParkerServiceManager in order to receive a service. The client will wait a reply when the service was complete.</li>
</div>

<h4>The DDRrobot</h4>
		<table>
			<tbody>
				<tr>
					<td>
						The model of the DDR-robot is related to the basicrobot given by the costumer: 	<a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.qak21.basicrobot/userDocs/basicrobot2021.html" target="web"> basicrobot2021.html</a>. <br>
						The DDR-robot could be a VirtualRobot, Mbot or Nanobot: 
						<li><bc>virtual</bc>: <br/><m>the virtual robot described in
<a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.virtualRobot2020/userDocs/VirtualRobot2021.html" target="robot">Virtual robot 2021</a>,
that can be launched by using the docker-compose file  
<a href="https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.issLabStart/Dockercompose/virtualRobotOnly2.0.yaml" target="code">virtualRobotOnly2.0.yaml</a></m>.
The support is: <a href="https://github.com/noemival/ParkManagerService_2021/blob/main/it.unibo.parkManagerService/it.unibo.sprint1/src/resources/robotVirtual/virtualrobotSupport2021.ktt" target="code">virtualrobotSupport2021.kt</a>
</li>
<li> <bc>nano</bc>: <br/><m>the self-made robot described in 
<a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.qak21.basicrobot/userDocs/LabNanoRobot.html" target="robot">LabNanoRobot | The home-made basicrobot</a></m>
The support is: <a href="https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.qak21.basicrobot/resources/robotNano/nanoSupport.kt" target="code">nanoSupport.kt</a>
</li>
<li> <bc>mbot</bc>: <br/><m>the  robot described in 
<a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.qak21.basicrobot/userDocs/Mbot3030.html" target="robot">Mbot3030 | The reference ddr robot</a> </m>
The support is: <a href="https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.qak21.basicrobot/resources/robotMbot/mbotSupport.kt" target="code">mbotSupport</a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
		<h6>The basicrobot</h6>
<table>
			<tbody>
<tr>
</tr>
				<tr>
					<td>
						The basicrobot will use to commununicate between the DDR robot and the transport-trolley because it allows us to execute the robot movement commands in a 'technology-independent' way, with respect to the nature of the robot (virtual or real). <br>

						The configuration file <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/basicrobotConfig.json" target="web"> basicrobotConfig.json</a>, located in the repository <a href="https://github.com/noemival/ParkManagerService_2021/tree/main/it.unibo.parkManagerService/it.unibo.final_sprint" target="web"> it.unibo.final_sprint</a>, is used to respect the Virtualrobot nature by the basicrobot.

					</td>
					<td style="width: 50%">
						<center><img src="./img/BasicRobotState.drawio.png" alt="mappa" width="70%" ></center> 
					</td>
				</tr>
			</tbody>
		</table> 

	<h4>The transport-trolley</h4>
		<div class="remark">
		 The transport-trolley will use the DDRrobot to execute its opertation that comes from the requirements of the application. In fact it should be able to generate a sequence of actions to reach the commands given by the ParkManagerService and exceute them sending the basic moves to the <kn>DDRrobot</kn> through the basic robot. 
		It is a computational entity with a own autonomous flow of control so it will be modelled as QActor.
		<br>The trasport trolley should reach the goal place in a organizzed way, as the costumer required, so it will represent the buisness logic of the DDR Robot.
		</div>
		<table>
			<tbody>
				<tr>
					<td>
						The trasport trolley should reach the goal place in a organizzed way: so the transport-trolley should planning (detection) the best sequence of actions and excecute them (actuation: e.g. sending messages to the basic robot).<br>
						The following file, given by the costumer, <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2021/blob/main/it.unibo.planner20/userDocs/LabPlanner.html" target="web"> LabPlanner.html</a> is able to planning the actions of a robot working in logical space using AI algorithms supporting. <br>
					</td>
					<td style="width: 50%">
						<center><img src="./img/TrolleyState.drawio.png" alt="mappa" width="70%" ></center> 
					</td>
				</tr>
			</tbody>
		</table> 

		<k>Transport-trolley/Planner </k>
		<br>

			The <a href="https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.planner20/resources/itunibo/planner/plannerUtil.kt" target="web"> plannerUtil.kt</a> is the support of the transport-rolley that is able to generate a plan of basic actions. 
			<br>
			The <a href="https://github.com/noemival/ParkManagerService_2021/blob/main/it.unibo.parkManagerService/it.unibo.final_sprint/parkingMap0.bin" target="web"> parkingMap0.bin</a> is the a binary file that represents the parking-area. It will be used by the planner to plan the path.
				<table>
					<tbody>
						<tr>
							<td>
								Because the transport-trolley shoud moves in a organizzed way the slots could be ordered in the following way so the first numbers will be near the INDOORarea and the transport troley will be faster to park the car. 
								The plannerUtil.kt consider the following pair of number the respective places:
								<ul>
								<li>("6","0") -> INDOORarea</li>
								<li>("6","4") -> OUTDOORarea</li>
								<li>("0","0") -> Home</li>
								</ul>
							</td>
					<td style="width: 50%">
					
					 <center><img src="./img/parkingArea2.png" alt="mappa" width="50%" ></center> 
							</td>
						</tr>
					</tbody>
				</table> 

						<pre>
	run itunibo.planner.plannerUtil.initAI()  
	println("&&&  trolley loads the parking map from the given file ...") 
	run itunibo.planner.plannerUtil.loadRoomMap("parkingMap0.bin")  
	<kc>//Set the parking area ...</kc>
	run itunibo.planner.plannerUtil.showMap()   
    run itunibo.planner.plannerUtil.showCurrentRobotState()		  
						</pre>

					
						After initializating the support the trasport trolley will generate the sequence of actions setting the cells goal with

						<pre>
	<kc>//for example</kc> run itunibo.planner.plannerUtil.planForGoal("6","0")

						</pre>
						<h3>Comunication</h3>
			<k>Transport-trolley/Basicrobot </k>
				
		<table>
			<tbody>
				<tr>
					<td style="width:50%" >
						<br> The Transport-trolley will send the command to the basicrobot using the asynchronous fire-forget pattern to reduce the quantity of messeges and prevent the application from waiting for a response.
					</td>
					<td><pre>
Dispatch cmd : cmd(MOVE)   
Context ctxparkingarea ip [host="localhost" port=8021]
QActor transporttrolley context ctxparkingarea{ 
	...
	forward basicrobot -m cmd : cmd(w)  
	...
} </pre>
					</td>
					
				</tr>
			</tbody>
		</table>

</div>

<h4>ParkServiceGUI & ParkServiceStatusGUI</h4>
	The costumer requires that it will be portable, indipendent from hardware components and from the operative system of the user device so the choise will be to realize a Web GUI.

	


<h4>The Outsonar</h4>
		<table>
			<tbody>
				<tr>
					<td>
						<kn>outsonar</kn>: an simulate or (optionally) a real device capable of detecting the presence of a car. It is in the OUTDOOR-area and sends the information taken via the network as event emitter.
						<br>
						 In this case it is a real device and the costumer gives us the seguent software: <a href="https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.rasp2021/resources/rasp/sonar/SonarAlone.c" target="web"> SonarAlone.c</a> and  <a href="https://www.acmesystems.it/HC-SR04" target="web">HC-SR04 ultrasonic sensor.</a> <br>
						 The <a href="https://www.acmesystems.it/HC-SR04" target="web">HC-SR04 ultrasonic sensor.</a> could be activated 'on demand'
						 or could be embedded in a component that provides a <k>'hot-source' of data</k>, i.e. an active component that emits information in a continuous way.
					
					</td>
				</tr>
		</tbody>
</table>


		<h4>The WebApplicationPms </h4>

		The ParkManagerService should be an application server and, as the costumer requires, it should be used by the clients through the ParkServiceGui and the ParkServiceStatusGui on any devices (smartphone, personal computer, tablet, etc). Therefore in our analysis we define it as an <kn>web application</kn> that should offer a distribuited service of car-parking.

	<div class="remark"> To destroy the abstraction gap is possible to use QACTOR which is a modelling language and defines a work model of the system based on actors behavior.
	</div>

<h2>Problem analysis</h2>

<div>
These are the components analyzed
<ol>
<li><a href="#transporttrolley">The TransportTrolley</a></li>
<li><a href="#weightsensor">The Weightsensor</a></li>
<li><a href="#outsonar">The Outsonar</a></li>
<li><a href="#fan">The Fan</a></li>
<li><a href="#thermometer">The Thermometer</a></li>

<li><a href="#theparkmanagerservice">The ParkManagerservice</a></li>
<ul>
	<li><a href="#parkmanagerservice">The ParkManagerservice</a></li>
<li><a href="#outmanager">The Outmanager</a></li>
<li><a href="#parkingmanager">The ParkingManager</a></li>
</ul>
<li><a href="#webgui">The WebGui</a></li>
<ul>
<li><a href="#parkservicegui">The ParkServiceGui</a></li>
<li><a href="#parkservicestatusgui">The ParkServiceStatusGui</a></li>
</ul>



</ol>
</div>
<hr>
	<div class="remark">
		To destroy the abstraction gap is possible to use QACTOR which is a modelling language and defines a work model of the system based on actors behavior. 
	</div>

	<hr>

<h3 id="transporttrolley">The TransportTrolley</h3>
		
				<ks>MoveToHome </ks>
				
						<br>  
						The transport trolley when recives the command moveToHome should be able to excecute the command but also it shouldn't complete it if there is another reqeust from the ParkManagerService.
<br><br>
		<ks>Load/Unload the car</ks>
				
						<br>  
						The transport trolley when arrives near a SLOT/INDOORAREA/OUTDOORAREA it should load/unload the car so it should simulate the correct direction and the time to do this operation.

	
					</td></br>
			
				</tr>
			</tbody>
		</table style="width:98%">
		<h3 id="weightsensor">Weightsensor</h3>
			
			<table>
					<tbody>
						<tr>
							<td>
										
							The Weightsensor is modelled as a mock QActor and it is an events emitter which are sent when the INDOORAREA is vacated. It should be able to send the information about the weight too. <br>
							To simulate this behavior the parkservicegui informs it that the client enters the car in the INDOORAREA thus it could start to send events until the transport-trolley takes the car and frees up the INDOORAREA. 
		
							</td>
							<td style="width: 55%">
					
					 <center><img src="./img/weightsensorState.png" alt="weightsensorState" width="100%" ></center> 
							</td>
						</tr>
					</tbody>
				</table> 
				<h4>Components comunication</h4>

		<table style="width:98%">	
				<tr>
						<k>Weightsensor </k>
						
					<td style="width:50%" >
						
						<br> The weightsensor as an events emitter
					</td>
					<td>
						<pre>
Event weightsensor : weightsensor (W)

Context ctxparkingarea ip [host="localhost" port=8021]

QActor weightsensor context ctxparkingarea{
	...
		emit weightsensor : weightsensor ($WEIGHT)
	...

}
					    </pre>
					</td>
					</tr>
				</tbody>
			</table>
			
<h3 id="outsonar">The Outsonar</h3>
 <center><table style="width:95%">
<tbody>	
<tr>
<td style="width:50%" ><h4>Sonar as event emitter</h4>

	For the real world, the  model of the <ks>sonar</ks> could be defined as a qak
<a href="https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.rasp2021/codedqak/sonarHCSR04Support2021.kt" target="code">sonarHCSR04Support2021.kt</a>
that embeds <a href="https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.rasp2021/resources/rasp/sonar/SonarAlone.c" target="code">SonarAlone.c</a> ,
<br/> <br/> 
<center><img src="./img/sonarSupport2021.PNG" alt="sonarSupport2021" width="50%" ></center>
<br/> 
This component is written in Kotlin and emits events. <br/><br/>
As an extensionons of the qak basic class
<a href="https://raw.githubusercontent.com/anatali/issLab2021/main/it.unibo.qakactor/src/main/kotlin/ActorBasic.kt" target="code">ActorBasic.kt</a>.

<div class="remark">
When using a real sonar, several 'bad' things can happen, including the possibility to generate spurios values.
</div>
</td>
</tr>
</tbody>

		</table></center>

<table> 		<h4 >Outsonar</h4>
<tbody>
						<tr>
							<td>
								In our analysis, the <ks>sonar</ks> is an autonmous active component that does not 'known' any other component.
								Thus the Outsonar is modelled as a mock QActor and it is an events emitter when the OUTDOORAREA is vacated.<br> 
								To simulate this behavior the transporttrolley inform it that there is a car in the OUTDOORAREA thus it could start to send events until the client takes the car and frees up the OUTDOORAREA. 
		
	
							</td>
							<td style="width: 55%">
					
					 <center><img src="./img/outsonarState.png" alt="outsonarState" width="70%" ></center> 
							</td>
						</tr>
					</tbody>
				</table> 

<!-- 
A simulator that emits the <ks>sonar:distance(D)</ks> event is defined in
<a href="../../it.unibo.rasp2021/codedqak/sonarsimulator.kt" target="code">sonarsimulator.kt</a>.
-->
<h4>Components comunication</h4>
			<table style="width:98%">	
				<tr>
						<k>Outsonar </k>
						
					<td style="width:50%" >
						
						<br> The outsonar as an events emitter
					</td>
					<td>
						<pre>
Event outsonar : outsonar (O)

Context ctxparkingarea ip [host="localhost" port=8021]

QActor outsonar context ctxparkingarea{
	...
		emit outsonar : outsonar(O)
	...

}
					    </pre>
					</td>
					</tr>
				</tbody>
			</table>
			<br>			
			

			
		<h3 >Outmanager</h3><table>
					<tbody>
						<tr>
							<td>
							The Outmanager was modelled as QActor and its aim is to send an alarm (event) when the OUTDOORAREA is still vacated over a DTFREE time. 
							It is a part of ParkManagerService and it is specialized to manage the outsonar information. 
							The reason why it is necessary modelled this actor is the implementation of timer and, thus, guarantee the fulfillment of other actions by other components while the timer is going.  
	
							</td>
							<td style="width: 55%">
					
					 <center><img src="./img/outmanagerState.png" alt="outmanagerState" width="70%" ></center> 
							</td>
						</tr>
					</tbody>
				</table> 
<h4>Components comunication</h4>

		<table style="width:98%">	
				<tr>
						<k>Outmanager/ParkManagerService </k>
					
					<td style="width:50%" >
						
						<br> The Outmanager will send dispatches to the
						ParkManagerService to inform it if the OUTDOORAREA is vacated or not. When it is over the DTFREE the OutManager will send to the ParkManagerService an alarm which is an event.
					</td>
					<td>
						<pre>
Dispatch outfree : outfree(free)

Context ctxparkingarea ip [host="localhost" port=8021]

QActor outmanager context ctxparkingarea{
...
	State work{
	...
		forward parkmanagerservice -m outfree : outfree (occ)
	...		
	} 	
	}
	State free {
		forward parkmanagerservice -m outfree : outfree (free)
	}
}
	

					    </pre>
					</td>
					</tr>
				</tbody>
			</table>
		
				<h3 id="fan">Fan</h3>
			<table>
					<tbody>
						<tr>
							<td>
								In this case the component will be activated by the ParkManagerService or the parking-manager.
								<br>The costumer didn't given any software or device about the component but the costumer asked us to use mock-actor or mock-objects to simulate the behavior.
								<br> The fan will be modeled as a QActor.
					</td>
							</td>
							<td style="width: 55%">
					
								<center><img src="./img/FanState.drawio.png" alt="FanState" width="400" ></center> 
							</td>
						</tr>
					</tbody>
				</table> 
				<h4>Components comunication</h4>

					<table >
			<tbody>	
				<tr>
						<k>ParkingManager/Fan</k>
						
					<td style="width:50%" >
						<br> The ParkingManager and the parking-manager will communicate with the fan with dispatches because it isn't necessary a response to continue the execution. 
						Furthermore, the ParkingManager will not send all the values generated by the thermometer, but only those that involve a change in the state of the fan, so as to reduce the number of messages exchanged.
					</td>
					<td>
						<pre>
Dispatch fanstart: fanstart(V)
Dispatch fanstop : fanstop(V)
						
Context ctxparkingarea ip [host="localhost" port=8021]

QActor parkmanagerservice context ctxparkingarea {
	...
		forward fan -m fanstart: fanstart(on) 
	...
		forward fan -m fanstop: fanstop(off)

}
					    </pre>
					</td>
					</tr>
				</tbody>
			</table>
		<h3 id="thermometer">Thermometer</h3>
			<br>
			<table>
					<tbody>
						<tr>
							<td>
								In our analysis, this element is an autonmous active component that does not 'known' any other component. Thus, it is actually modelled as an emitter of events.
								The thermometer will be modeled like QActors.</li> 
							</td>
							<td style="width: 55%">
								<center><img src="./img/ThermoterState.drawio.png" alt="ThermoterState" width="40%" ></center> 
							</td>
						</tr>
					</tbody>
			</table> 
				<br>	
				<h4>Components comunication</h4>
			
			<table>
				
<table style="width:100%">
			<tbody>	
				<tr>
						<k>Thermometer</k>
						
					<td style="width:50%" >
						
						<br> The thermometer as an emitter of event.
					</td>
					<td>
						<pre>
Event temperature : temperature (T)

Context ctxparkingarea ip [host="localhost" port=8021]

QActor thermometer context ctxparkingarea{
	...
		emit temperature : temperature ($VALUE)
	...

}


					    </pre>
					</td>
					</tr>
				</tbody>
			</table>

	
	<h3 id ="theparkmanagerservice">ParkManagerService</h3>
	<div class = "remark">
		The ParkManagerService is an application server that interacts via network with OUTSonar, weightsensor, trolley, thermometer and fan. It should build ParkServiceGUI build ParkServiceStatusGUI. The ParkManagerService could be modelled as a combination of more QActors (e.g. Outmanager and ParkingManager).
			
	</div>
		<h6 id ="parkmanagerservice">ParkManagerService</h6>

		<table style="width:98%">
		<tbody>	
				<tr>
					<td  >
					 The ParkManagerService QActor:
					<ul>
						 <li>manage the requests from the clients, excecute them and elaborate the replies;</li>
						 <li>manage the parking-area with information of the weightsensor and the outsonar. </li>
					 </ul>
							<td >
					
					 <center><img src="./img/pmsstate.png" alt="parkManagerServiceState" width="70%" ></center> 
					</td>
				</tr>
		</tbody>
		</table style="width:98%">
	


			<h5 id="parkmanagerservicecomunication">Components comunication</h5>
<k>ParkManagerService/TransporTrolley </k>
			<table>
				<tbody>	
					<tr>
						<td style="width:50%" >
						
						<br> The ParkManagerService will send the command to the transport-trolley in a asynchronous way to reduce the quantity of messages and prevent the application from waiting for a response.
						</td>

						<td>						
							<pre>

Dispatch cmd : cmd(MOVE) 

Context ctxparkingarea ip [host="localhost" port=8021]

QActor parkmnagerservice context ctxparkingarea{ 
	...
	forward transporttrolley -m cmd : cmd(w)  	
	...
}
					    </pre>
					

					</td>
					
				</tr>
			</tbody>
		</table>	
		
		<h6 id ="outmanager">Outmanager</h6>
		<table>
		<tbody>
						<tr>
							<td>
							The Outmanager was modelled as QActor and its aim is to send an alarm (dispatch) when the OUTDOORAREA is still vacated over a DTFREE time. 
							It is a part of ParkManagerService and it is specialized to manage the outsonar information. 
							The reason why it is necessary modelled this actor is the implementation of timer and, thus, guarantee the fulfillment of other actions by other components while the timer is going.  
	
							</td>
							<td style="width: 55%">
					
					 <center><img src="./img/outmanagerState.png" alt="outmanagerState" width="70%" ></center> 
							</td>
						</tr>
					</tbody>
				</table> 
		<h5 id="outmanagercomunication">Components comunication</h5>
		<table style="width:98%">	
				<tr>
						<k>Outmanager/ParkManagerService </k>
					
					<td style="width:50%" >
						
						<br> The Outmanager will send dispatches to the
						ParkManagerService to inform it if the OUTDOORAREA is vacated or not. When it is over the DTFREE the OutManager will send to the ParkingManager an alarm which is a dispatch.
					</td>
					<td>
						<pre>
Dispatch outfree : outfree(free)
Dispatch alarm : alarm(V)
Context ctxparkingarea ip [host="localhost" port=8021]

QActor outmanager context ctxparkingarea{
...
	State work{
	...
		forward parkmanagerservice -m outfree : outfree (occ)

		forward parkmanagerservice -m alarm : alarm(V)
	...		
	} 	
	}
	State free {
		forward parkmanagerservice -m outfree : outfree (free)
	}
}
	

					    </pre>
					</td>
					</tr>
				</tbody>
			</table>
	<h6 id ="parkingmanager">ParkingManager</h6
		>
	<table>
					<tbody>
						<tr>
							<td>
								<ul>
								<li>The ParkingManager  interacts via network with the the thermometer, fan, trolley and the ParkServiceStatusGui. 
								It is a part of ParkManagerService and it is specialized to manage the parkingmanager human behavior. 
								In our analysis the existence of the ParkingManager is related to the requirement to stop the transport-trolley which cannot be done by ParkManagerService;</li>
								<li>The ParkingManager should recive the information of the transport-trolley and the fan so its is like an observer too. 
								</li>
							</ul>
							</td>
							<td style="width: 55%">
								<center><img src="./img/pmstate.png" alt="ParkingManagerState" width="400" ></center> 
							</td>
						</tr>
					
					</tbody>
			</table> 
	<h5 id="parkingmanagercomunication">Components comunication</h5>		
<table>			<tbody>	
				<tr>
						<k>ParkingManager/TransportTrolley</k>
						
					<td style="width:50%" >
						 The ParkingManager will send the command to the transport-trolley in a asynchronous way to reduce the quantity of messages and prevent the application from waiting for a response.
					</td>
				<td style="width:50%" >

						<pre>
Dispatch trolleystop :  trolleystop(V)
Dispatch trolleyresume :  trolleyresume(V)

Context ctxparkingarea ip [host="localhost" port=8021]

QActor parkingmanager context ctxparkingarea{ 
	...
	forward transporttrolley -m trolleystop : trolleystop(w)  	
	...
	forward transporttrolley -m trolleyresume : trolleyresume(w)  	

}


					    </pre>
					</td>
					</tr>
				</tbody>
			</table><br>
<table >
			<tbody>	
				<tr>
						<k>ParkingManager/Fan</k>
						
					<td style="width:50%" >
						<br> The ParkingManager will send the command to the fan in a asynchronous way to reduce the quantity of messages and prevent the application from waiting for a response.
					</td>
					<td>
						<pre>
Dispatch fanstart: fanstart(V)
Dispatch fanstop : fanstop(V)
						
Context ctxparkingarea ip [host="localhost" port=8021]

QActor parkmanagerservice context ctxparkingarea {
	...
		forward fan -m fanstart: fanstart(on) 
	...
		forward fan -m fanstop: fanstop(off)

}
					    </pre>
					</td>
					</tr>
				</tbody>
			</table>
<br>
			<k>ParkingManager</k>
				<table style="width:100%">
<td style="width:50%" >		
					
						<br> 
The interaction follow is modelled with events because the receiving is uknown in the requirements and other components could be intrested of what is happening in future.
					</td>
					<td>
						<pre>
Event warning :  warning(V)
Event alarm :  alarm(V)
					
Context ctxparkingarea ip [host="localhost" port=8021]

QActor parkingmanager context ctxparkingarea {
	...
		emit warning : warning(V)
		emit alarm : alarm(V)


}
					    </pre>
					</td>
					</tr>
				</tbody>
			</table>
<br>
	<h3 id ="webgui">The WebGui</h3>

	<div class="remark">
		The Gui interface allows the customer to communicate with our system. Because it is preferable that the grafic interfaces will be portable, that are indipendent from hardware components and from the operative system of the user device, the choise will be to realize the
								Web-application in the following way:
								<ul>
									<li>they could be two HTML pages both with INPUT sections (e.g. CARENTER or stop/resume the trolley) and OUTPUT sections (e.g. TOKENID, temperature, current state).</li>
								</ul>
								The techology should be SpringBoot to reduce development time.
								Right now we just confine its behavior to a mock-qactor. Its complete realization will be done in the project phase.
	</div>

	<h6 id ="parkservicegui">The ParkServiceGui</h6>
			<table>
					<tbody>
						<tr>
							<td>

								The ParkServiceGui should use by the client to inform the application the intent to enter or take the car. It should also inform the client if he should wait to take the car, or if there aren't any slots in the parking-area, etc.
								In this case we will simulate the behaviour of the client: it is an mock QActor.

								
							</td>
							<td style="width: 55%">
					
					 <center><img src="./img/pssgstate.png" alt="ParkingServiceGui" width="100%" ></center> 
							</td>
						</tr>
					</tbody>
				</table> 

			<h5 id="parkserviceguicomunication">Components comunication</h5>
		<table >
			<tbody>	
				<tr>
						<k>ParkingServiceGui/ParkManagerService </k>
						
					<td style="width:50%" >
						
						<br> The interaction follow the request/response model because when the client send a command the application must answer with helpful information (e.g. SLOTNUM, TOKENID...)
					</td>
					<td>
						<pre>
Request carenter : carenter(C)
Reply receipt : receipt(I)
Request notifyIn : notifyIn(N)
Reply informIn : informIn(S)
Request pickup : pickup(TOKENID)
Reply ok : ok(O)
Context ctxparkingarea ip [host="localhost" port=8021]

QActor parkingservicegui context ctxparkingarea{ 
	...
	request parkmanagerservice -m notifyIn : notifyIn(A) 
	...
	request parkmanagerservice -m carenter : carenter ($SLOTNUM)
	...
	request parkmanagerservice -m pickup : pickup($TOKENID)
}
QActor parkmanagerservice context ctxparkingarea{ 
	...
	replyTo notifyIn with informIn : informIn($SLOTNUM)
	...
	replyTo carenter with receipt : receipt($TOKENID)
	...
	replyTo pickup with ok : ok($OUTFREE)
}</pre>
					</td>
					</tr>
				</tbody>
			</table>
	<h3 id ="parkservicestatusgui">The ParkServiceStatusGui</h3>
		<table>
					<tbody>
						<tr>
							<td>
							
								The ParkServiceStatusGUI should monitor the the system current state. It should ask to the application the information needed. The implementation could be done with a polling mechanism, that is a request/response interaction, but this is only one possible solution. Another one could be a dispatch interaction, or using an observer.
								In this case we will simulate the behaviour of the parking-manager(human): it is an mock QActor.


					</td>
							</td>
							<td style="width: 55%">
					
								<center><img src="./img/psgstate.png" alt="ParkServiceStatusGUIState" width="400" ></center> 
							</td>
						</tr>
					</tbody>
				</table> 
		<br>
	


			<h5 id="parkmanagerservicecomunication">Components comunication</h5>
				<table >
				<tbody>	
					<tr>
							<k>ParkServiceStatusGui</k>
							
						<td style="width:50%" >
						<br> 
The interaction follow is modelled with events because the ParkServiceStatusGui operations will processing like a botton which are like an observable in an distribuited system. 
						</td>
						<td>
							<pre>
Event stateChangetrolley :  stateChangetrolley (V)
Event stateChangefan :  stateChangefan (V)
						
Context ctxparkingarea ip [host="localhost" port=8021]

QActor parkservicestatusgui context ctxparkingarea {
	...
		emit stateChangetrolley : stateChangetrolley(stop)
		emit stateChangefan : stateChangefan(work)
	...
		emit stateChangetrolley : stateChangetrolley(work)	
		emit stateChangefan : stateChangefan(stop)

}
						    </pre>
						</td>
						</tr>
					</tbody>
				</table>
	<h3>Logical Architecture</h3>

				<table style="width:98%">	
		<td style="width:50%" >
				<center><img src="./img/architettura_logica.png" alt="architettura_logica_iniziale" width="60%" ></center> 
		</td>
	</table>
	<div class="remark">
The executable model is the following file: <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/src/sprint_final.qak"target="web">sprint_final.qak</a></p>				
</div>	

<h2>Testplan</h2>
		<ks>Testplan 1</ks>:  the testplan should check the correspondence of the movements between the transport-trolley and the basicrobot.
		The test will be done by comparing two strings.
		<ul><li>path: are the commands to reach the goal;</li>
		<li>result: are the real commands sending to the DDR robot from the basic robot.
		</ul>At the end of the execution the two strings should be equals. </li>
		<br><br> The code is the following file: <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/test/it/unibo/final_sprint/TestPlan1.kt"target="web">TestPlan1.kt</a>.  <p>
		<ks>Testplan 2</ks>: we should simulate and check if the parkservicegui receive the correct Slotnum.<br><br> The code is the following file: <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/test/it/unibo/final_sprint/TestPlan2.kt" target="web">TestPlan2.kt</a>.  <p> 
		<ks>Testplan 3</ks>: we should simulate and check if the parkservicestatusgui receive the alarm from the outmanager when the OUTDOORAREA is still vacated over a DTFREE time.<br><br> The code is the following file: <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/test/it/unibo/final_sprint/TestPlan3.kt" target="web">TestPlan3.kt</a>.  <p> 
		<ks>Testplan 4</ks>: we should simulate and check if the parkingmanager turn on/off the fan if the temperature is higher/lower than TMAX.<br><br> The code is the following file: <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/test/it/unibo/final_sprint/TestPlan4.kt" target="web">TestPlan4.kt</a>.  <p> 
		<ks>Testplan 5</ks>: we should simulate and check if the parkingmanager stop/resume the transport-trolley when the temperaature is higher/lower then TMAX.
		<br><br> The code is the following file: <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/test/it/unibo/final_sprint/TestPlan5.kt" target="web">TestPlan5.kt</a>.  <p>


<h2>Project</h2> 

<h4>WebApplicationPms</h4>

	The WebApplicationPms will be a system of actors and other components that implements the required automation functions. It is a distributed service accessible via HTTP:
	<pre>http://localhost:8081</pre> 
	The service communicates with external devices also via MQTT, COAP and TCP. <br>

	The WebApplication is in the following folder: <a href="https://github.com/noemival/ParkManagerService_2021/tree/main/it.unibo.parkManagerService/it.unibo.final_sprint/it.unibo.WebApplicationPms"target="web">it.unibo.WebApplicationPms</a>

<h6>Weightsensor</h6>
<table>
				<tbody>	
						<tr>
							<td>
								<ul>
								<li>The device will be simulated using a GUI interface where it is possible to fill in a form the information of weight. </li>
								<li> The GUI will be embedded in a qactor such that it will be transfert in a infrastructure capable to interact in a distribuited system. </li>
								<li>The comunication protocol chosen is MQTT because, nevetherless all the possibilities given by the qactor technology, it is the best one, in this case, to implement the requiremet of the costumer to ask the information to the resource only when they are necessary. </li>
								<li>Furthermore to achieve this requirement the qactor weighsensor was implemented as a filter such that reduce the message exchanged.
								</li>
							</ul>
<k>mqttBroker</k> "broker.hivemq.com" : 1883 <ks>eventTopic "weightsensor/data"</ks>
</pre>
</li>
</ol>

</li> 
	
							</td>
							<td style="width: 55%">
								<pre>
mqttBroker "localhost" : 1883 eventTopic "weightsensor/data"

Context ctxweightsensor ip [host="localhost" port=8018]  


QActor weightsensor context ctxweightsensor{
...
 State working {
	 	println("weihtSensor :  working") 
	 	[#var Weight = gui.value #]
	 	 
	 	  println(Weight)
	
	 	[#if(Weight == 0 && carNotDetected == false){
	 		carNotDetected = true
	 		emit("weight", "weight($Weight)")
	 	}else if(carNotDetected ==  true && Weight != 0){
	 		carNotDetected =  false 
	 		emit("weight", "weight($Weight)")
	 	}#]
	 
	 	
	 }Transition t0 whenTime 2000 ->working
	}
		</pre>
							</td>
						</tr>
					</tbody>
				</table> 
				<h6>Thermometer</h6>
<table>
				<tbody>	
						<tr>
							<td>
								<ul>
								<li>The device will be simulated using a mock qactor, called mockTherm, that will generate random values between 0 and 50. The values will be perceived by another qactor such that the simulated device will be tranfert in a infrastructure capable to interact in a distribuited system, indeed this qactor will communicate to our application by sending a dispatch.  </li>
								<li> The dispatch choice was made because we know the recipient and because the asynchronous comunication allows to not to lose temperature information </li>
								<li>Neverthenless it could be verified that there will be an inconsistency between the state of the parkingarea and the application, because of dispatches queque, in real case it will be difficult to  happen thanks to the fact that the parkingmanager recived, besides temperature dispatches, only another type of messages only one time when the temperature over/undercome tmax.
								</li>

</ul>
	
							</td>
							<td style="width: 55%">
								<pre>
Context ctxthermometer ip [ host= "localhost"   port= 8015 ]
Context ctxparkingarea ip [ host= "127.0.0.1" port=8021 ]

ExternalQActor parkingmanager context ctxparkingarea

	
 QActor thermometer context ctxthermometer{
 ...
 tate handleMsg{
	onMsg(temp : temp(T)){
    	[# var T= payloadArg(0)#]
    	    println("thermometer | work $T") 
    	    	
    		forward parkingmanager -m  temperature : temperature ($T)
			
    	}
	
}Goto work
}

		</pre>
							</td>
						</tr>
					</tbody>
				</table> 

			<h6>Fan</h6>
<table>
				<tbody>	
						<tr>
							<td>

								<ul><li>The device will be simulated using a GUI interface where is possible to view the its state. </li>
								<li> The GUI will be embedded in a qactor such that it will be transfert in a infrastructure capable to interact in a distribuited system. </li>
								<li>The comunication protocol chosen is COAP because it allows to implement the  observe pattern. Indeed the fan should observe the state changes of the fanmanager resourced to do its operation because it has a reactive behaviour.  </li></ul>
	
							</td>
							<td style="width: 55%">
								<pre>
Context ctxfan ip [host="localhost" port=8017]  

QActor fan context ctxfan{
...
State handleState{
		[#stateFan = utility.HandleData().getState("fanmanager")
	 	gui.setState(stateFan)#]
	 		 
	 	//updateResource[#"stateFa n()"#]
	}
	Transition t0 whenTime 2000 -> handleState
	
	 
}

		</pre>
							</td>
						</tr>
					</tbody>
				</table> 
				<h6>Outsonar</h6>
<table>
				<tbody>	
						<tr>
							<td>
								<ul><li>The real sonar, described in the problem analysis,  will generate the values as an event emitter. The values will be perceived by another qactor, outsonar, such that avoid an event communication with our application, so it will send dispatches to the outmanager.  </li>
								<li> The dispatch choice was made because we know the recipient and because the asynchronous comunication allows to not to lose OUTDOORAREA information</li></ul>
	
							</td>
							<td style="width: 55%">
								<pre>
Context ctxsonaronrasp   ip [host="localhost"     port=8070]

Context ctxparkingarea ip [ host= "127.0.0.1" port=8021 ]	//insert ip deploy on Pc 

ExternalQActor outmanager context ctxparkingarea

CodedQActor sonarsimulator  context ctxsonaronrasp className "sonarSimulator"  
CodedQActor sonardatasource context ctxsonaronrasp className "sonarHCSR04Support2021"

QActor outsonar context ctxsonaronrasp {     
...
State handleSonarData{
  		printCurrentMessage
		[# var DIST=0 #]
		println("outsonar | handlemsg")
		onMsg( sonar : distance(D) ){
			[# DIST = payloadArg(0).toInt() #] 
			println(DIST)		
			if[#DIST<20 #]{ 
				forward outmanager -m outsonar : outsonar (O)
				[#send = "true"#] //trasformarli in dispatch
			}if[#DIST>=20 && send=="true" #]{ 
				forward outmanager -m takecar : takecar(P)
				[#send = "false"#]  //trasformarli in distpatch
			}
		}
   		    onMsg( sonar : distance(D) ){
  		 	[# val D = payloadArg(0) 
  		 	#]  
  		 	println("spono")
  		 	emit sonarrobot : sonar($D)*/
  		 
  	}
  	Transition t0 whenEvent sonar -> handleSonarData
  
 }

		</pre>
							</td>
						</tr>
					</tbody>
				</table> 


				<h6>ParkServiceGui</h6>
			
			<table>
					<tbody>
						<tr>
							<td>
								The ParkServiceGui will be a series of responsive HTML pages with the aim to show what operations the client could be: <br>
								<kn>parking phase:</kn>it is composed by two pages:
									<ul>
										<li>notify in: an html page with a button "notifyIn" pressed by the user to inform the system his intrest to use the service.</li>
										<li>carenter: an html page with a input form where the client should put his email and a button pressed by the user to inform the system that the robot could take the car. The system will use the email to send to the user the link for go to the pick up phase.
										</li>

										</ul>
										<kn>pickup phase:</kn> it is composed by one page and it is accessible only using the email sending previously. There is only one button "pickup" used to inform the system that the client want take its car. If the system cannot process the command it will inform the client to try later. <br><br> 
								The EmailService was implemented to guarantee the right correlation between client and his TOKENID. If the client picked up his car the system is able to recognised and avoid the client to use two times the same link. 
							</td>
							<td style="width: 55%">
					
					 <center><img src="./img/htmlpages.png" alt="ParkingServiceGui" width="100%" ></center> 
							</td>
						</tr>
					</tbody>
				</table> 	

<h6>ParkServicStatusGui</h6>
			
			<table>
					<tbody>
						<tr>
							<td>
								The ParkServiceStatusGui will be an  responsive and interactive HTML page with the aim to show what is the state of the parkingarea.
								It will be composed of two sections:<ul>
								<li><kn>output:</kn>  where are shown the information of the trolley, fan, temperature and if the OUTDOORAREA is still vacated over a DTFREE time;
								</li>
								<li><kn>input:</kn> where the manager could change the state of the fan and the trolley if the temperature over/undercome tmax.</li></ul>
								The page will be manage by the ControllerPm implemented using SpringBoot and with the supporting of javascript and Stomp. 
							</td>
							<td style="width: 55%">
					
					 <center><img src="./img/htmlpages2.png" alt="ParkingServiceGui" width="100%" ></center> 
							</td>
						</tr>
					</tbody>
				</table> 	
	<h4>Authentication</h4>
<ul>
								<li> The manager should authenticate himself and define his MANAGER roles, then the manager should see the HTML page.</li>
								<li> The authentication could be done using WebSpringSecurity and defining all the configuration of the application. </li>
								<li>	The code is in Websecuriticonfig<a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/it.unibo.WebApplicationPms/src/main/kotlin/it/unibo/webApplicationPms/configuration/WebConfigSecurity.kt" target="web">WebConfigSecurity.kt</a>.</li></ul>
	
			

		<h6>ControllerWeighSensor</h6>
	<table>
				<tbody>	
						<tr>
							<td>
								<ul><li>The ControllerWeightSensor is a controller used to manage the information sending by the weightsensor which simulate the car detection in the INDOORAREA. 
								<li>It should forward the INDOORAREA information to the parkmanagerservice but also update the CARENTER button behaviour of the GUI.  </li>
								 <li>The ControllerWeightSensor receives the weighsensor-data using MQTT because this protocol is able to realize the event based comunication thanks to the characteristic of decoupling sender and receiver.</li>
								 <li>The ControllerWeightSensor will send a dispatch to the parkingmanagerservice to avoid that it will wait a response and because it knows the recipient.</li></li>
<pre>
<k>mqttBroker</k> "broker.hivemq.com" : 1883 <ks>eventTopic "weightsensor/data"</ks>
</pre>
</li>
</ol>

</li> 
	
							</td>
							<td style="width: 55%">
								<pre>
@Controller
class ControllerWeighSensor {					
	@MqttSubscribe(topic = "weightsensor/data" , qos = AT_LEAST_ONCE)
	fun subscribe ( payload:String) {
		println( "weight = "+payload )
		appConnection.sendForward("weightsensor","weight(${payload})", "weightsensor")
		stateButtonCarEnter = "Enabled"
		}
}	
				</pre>
							</td>
						</tr>
					</tbody>
				</table> 

<h6>ControllerPms</h6>
		<table>
				<tbody>	
					<tr>
						<td style="width:50%" >
							<ul><li>The ControllerPMS represents the WebApplication controller that responsible for processing incoming requests, preparing a model, and returning the view to be rendered as a response.</li>
							<li>It defines an API with the purpose of creating a standard communication so that external components can communicate with our application and without knowing its implementation aspects.</li>
							<li>
							With the respect of clean architecture the ControllerPMS should implement the view managing of the Web application.</li>
						

						</td>
						<td  style="width:50%">
</pre>
<pre>
	<kc>//example of implementation</kc>
  @RequestMapping("/carenter", method = arrayOf(RequestMethod.GET))
    fun carenter(button: Button, slotnum: Slotnum): String {
        var slot = getSlotNum()
        if (!slot.equals("0")) {
            button.enterdisabled = true
            slotnum.slotnum = slot.toInt()
            println(slotnum.slotnum)
        } else {
            button.enterdisabled = false
        }
        return "carenter.html"
    }

     <kc>// used to connecting the WebApplication to the service </kc>
 fun createconnection(messageId: String, content: String): String{ 
        connToPms = connQakBase.create(ConnectionType.TCP)
        connToPms.createConnection()
        val msg = MsgUtil.buildRequest("parkmanagerserviceProxy", messageId, content, qakdestination)
        answer = connToPms.requestWithRensponse(msg)
        print(answer)
        return answer
    }
</pre>				</td>
					
				</tr>
			</tbody>
		</table>
<h6>ControllerPm</h6>
	<table>
				<tbody>	
						<tr>
							<td>
							<ul><li>The ControllerPM represents the WebApplication controller that responsible for processing incoming manager requests, preparing a model, and returning the view to be rendered as a response.</li>
							<li>It defines an API with the purpose of creating a standard communication so that external components can communicate with our application and without knowing its implementation aspects.</li>
							<li>
							With the respect of clean architecture the ControllerPM should implement the view managing of the Web application.</li>
							<li> The ControllerPm will send a dispatch to the parkingmanager to avoid that it will wait a response and because it knows the recipient. </p>
							</li></ul>
	
							</td>
							<td style="width: 55%">
								<pre>
 final var coapOut   = CoapSupport("coap://localhost:8021", "ctxparkingarea/outmanager")
    final var coapPm  = CoapSupport("coap://localhost:8021", "ctxparkingarea/parkingmanager")
    ...
    @RequestMapping("", method = arrayOf(RequestMethod.GET))
    fun entry(model: Model): String {

        sysUtil.colorPrint("HIController | entry model=$model", Color.GREEN)

        return  "pm.html"
    }

    @RequestMapping("", method = arrayOf(RequestMethod.POST))
    fun stateChange(@RequestParam (value = "but") value: String?):String{
       sendForward("stateChange","stateChange($value)","parkingmanager")
        return "pm.html"

    }
								</pre>
							</td>
						</tr>
					</tbody>
				</table> 
<h4>CoapHandlers</h4>
	
								<li>
									The information reguarding trolley, fan, temperature and alarm are processed by two CoapHandlers, <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/it.unibo.WebApplicationPms/src/main/kotlin/it/unibo/webApplicationPms/controller/PmCoapHandler.kt" target="web">PmCoapHandler.kt</a>. and <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/it.unibo.WebApplicationPms/src/main/kotlin/it/unibo/webApplicationPms/controller/OutCoapHandler.kt" target="web">OutCoapHandler.kt</a>, their behaviour is the same, indeed they should observe the parkingmanager and the outmanager which update the state with JSON value and update the html page using the websocket.</li>
									<li>The updating information sent over the websocket is handled by an stomp subscriber activated during the connect() operation defined in src/main/resources/static/app.js (called when the HTML page is loaded).
									</li>
									<li>We will use STOMP messaging with Spring to create an interactive web application. Therefore the manager could see all the information updated and change the state using a TOVER/TUNDER button. 
									 </li>

	

				
	<h6>ParkingManager</h6>
	<table>
				<tbody>	
						<tr>
							<td>
								<ul><li>The parkingmanager should collect all the state information of the fan, trolley and thermometer and forward them to the PmController which should update the GUI using COAP. </li>
								<li>The temperature will be recived as a dispatch, wherease fan and trolley state because they are observable resource, will be taken using COAP.</li>

								<li>To manage fan and trolley the parkingmanager, after recived the command from the ControllerPm of changing the state, will change the states of the trolley and the fan using a dispatch</li>
								<li>The choice of the dispatch was made to avoid that the parkingmanager wait a response and because the message should't be lose. </li>
								<li>The downside is that the trolley could recived other dispatch messages and the one sending by the parkingmanager could be processed too later the button pressed, its structure was made to avoid this situation and mantain the consistency between the manager request and the state of the parkingarea. </li></ul>
	
							</td>
							<td style="width: 55%">
								<pre>

updateResource [#"{\"statetrolley\":\"$stateTrolley\", \"statefan\":\"$stateFan\", \"temp\":\"temp($temp1)\"}"#] 
				</pre>
							</td>
						</tr>
					</tbody>
				</table> 
				<h6>ParkManagerService</h6>
								<ul><li>The parkmanagerservice should process the clients requests which are sent by the ControllerPms.</li>
								<li>When a request arrived the parkmanagerservice shoud verified the state of the INDOORAREA/OUTDOORAREA, appropriately updatated by the messages sent by  outmanager and ControllerWeightSensor. If the constraints are satisfied the parkmanagerservice will send to the trolley the commands and it will reply to the client the impossibility or otherwise of fulfilling the request.   </li>

								<li>The communication between parkmanagerservice and ControllerPMS will be request-response because requests as in the requirements need to be answered</li>
								<li>The communication between parkmanagerservice and the trolley will be asynchronous because the task of checking the state of the transport trolley is of the parkingmanager. </li></ul>
							
	
				<h6>Fanmanager</h6>
	<table>
				<tbody>	
						<tr>
							<td>
								<ul><li>The Fanmanager is a qactor introduced to satisfy the aim of the right correlation between the information taken by the parking manager and the information observed from the parkingmanager. </li>
								<li>The Fanmanager will be the resources observed from the real fan device and from the parkingmanager.</li>
							</ul>
							</td>
							<td style="width: 55%">
								<pre>

QActor fanmanager context ctxparkingarea{    
	
	State s0 initial {  
		println("fan | start")
	
	}Goto stopped   
	
	State stopped {
		println ("fan | stopped")
		updateResource [#"fan(stop)"#] 
		
	}Transition t0 whenMsg fanstart->working
				  
	State working {
		println("fan | working")
		updateResource [#"fan(work)"#]
	
	}Transition t0 whenMsg fanstop->stopped	
}

				</pre>
							</td>
						</tr>
					</tbody>
				</table> 
				<h6>Outmanager</h6>
	<table>
				<tbody>	
						<tr>
							<td>
								<ul><li>The outmanager should sent the information about the OUTDOORAREA to the ControllerPm to update the GUI and to the parkmanagerservice to avoid an exceed of messages exchanged</li> 
								<li>The comunication between the outmanager and the ControllerPm (OuCoapHandler) is made using COAP to implement the observe pattern and avoid that the controller will wait a response.</li>
								<li>The comunication between the parkingmanagerservice will be using dispatch message because it is not interested in a response and because it knows the recepient. </li></ul>
	
							</td>
							<td style="width: 55%">
								<pre>

updateResource [# "{\"alarm\":\"alarm(occ)\"}" #] 
...
updateResource [# "{\"alarm\":\"alarm(free)\"}" #] 


				</pre>
							</td>
						</tr>
					</tbody>
				</table> 


<br><br>
		<h6>The transport-trolley</h6>
		<table>
				<tbody>	
					<tr>
						<td style="width:50%" >
							<ul><li>To sadisfy the single responsibility principle (SRP) it was decided to create a support for the transpor trolley.</li>
							<li><br>The tasks of the <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/src/utility/TrolleyPlannerSupport.kt"target="web">TrolleyPlannerSupport.kt</a> are to plan the greatest path and update the map, thus the transporttrolley will have the only responsibility of sending the commands to the basicrobot.</li></ul>	
						
						</td>
						<td>						
							<center><img src="img/transport_trolley_project_sprint1.png" alt="mappa" width="50%" ></center> 
						</td>
					
				</tr>
			</tbody>
		</table>
<h6>The basicrobot</h6>
			<table>
				<tbody>	
					<tr>
						<td style="width:50%" >
							 <ul><li>The basicrobot, as saied in analysis requirements phase, interacts with the real robot throught the object  <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/src/unibo/robot/robotSupport.kt"target="web">robotSupport.kt.</a>
							<br></li>
							<li>It is the adatper for the devices described in the configuration file : <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/src/unibo/robot/robotSupport.kt"target="web">basicrobotConfig.json</a></li>
							<li>In this project it is used a virtual robot that is inside the vitual evirorment WEnv.</li> 
							<li>The messages will be sent to the websoket (port:8091).
							</li></ul>
						</td>
						<td>						
							<center><img src="img/basic_robot_project.png" alt="mappa" width="50%" ></center> 
						</td>
					
				</tr>
			</tbody>
		</table>
		
<h3>Logical Architecture</h3>
<table>	
		<td>
				<center><img src="img/architettura_logicafinal_project.png" alt="mappa" width="45%" ></center> 
		</td>
	</table>
<h2>Testing</h2>
<p><ks>Testing1</ks>: we should simulate and check parcking-phase and pickup-phase requirements. Assuming there is one slot free, the temp is constant, fan stopped and INDOORAREA/OUTDOORAREA are free.
 To do this we will send an enter, carenter and pickup requests and we will check 
 <li>the parkmanagerservice is in the correct state;</li>
 <li>the client received the right aswers;</li>
 <li> the parkingmanager see the right information.</li>

After that we will try to do another enter request and we will check if the system will not process it because the INDOORAREA is still vacated and the slotnum are all occupied. 
<p>The code is present in the following file: <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/testing/Testing.kt"target="web">Testing.kt</a> </p>

<p><ks>Testing2</ks>: we should simulate and check monitor and manage requirements. To do this we will send a temperature over 35 an we will check if the information recived from the application will be correct. <br>
Then we will check after simulate the button pressed, if the state will change and it is correct. <br>
In this test we will check if the ParkServiceStatusGui received the information of DTFREE time over too.</p>

<p>The code is present in the following file: <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/testing/Testing2.kt"target="web">Testing2.kt</a> </p>

<p><ks>Testing3</ks>: we should check if the application will not process a pickup request if the OUTDOORAREA is still vacated.</p>


<p>The code is present in the following file: <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/testing/Testing3.kt"target="web">Testing3.kt</a> </p>


To realize an authomatized test we will use JUNIT.

</div>

<div class="remark">
The QActor excecutable model after project phase is the following file: <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/it.unibo.final_sprint/src/sprint_final_project.qak"target="web">sprint_final_project.qak</a></p>	
</div>
<h2>Deployment</h2>
	
The project is located in the repository: <a href="https://github.com/noemival/ParkManagerService_2021/tree/main/it.unibo.parkManagerService"target="web">https://github.com/noemival/ParkManagerService_2021/tree/main/it.unibo.parkManagerService</a></p>

	

<h3>OutSonar Configuration <em>ResourceAware</em></h3>
<table style="width:100%" border="1">

<tr>
<td style="width:50%">
<center><img src="./img/sonarpipeDistrib.png" alt="sonarpipeDistribonRasp" width="90%" ></center>
 

Execute <a href="https://github.com/noemival/ParkManagerService_2021/tree/main/it.unibo.parkManagerService/it.unibo.sonarRaspberry-1.0/bin" target="web">it.unibo.sonarRaspberry</a> on RaspberryPi
</td>
<td>
<pre>
<m>
%====================================================================================
% sonaronrasp description   (file <ks>sonaronrasp.pl</ks> )
%====================================================================================
<k></k>
context(ctxsonaronrasp, "localhost",  "TCP", "8070").
context(ctxparkingarea, "127.0.0.1",  "TCP", "8021").
 qactor( outmanager, ctxparkingarea, "external").
  qactor( sonarsimulator, ctxsonaronrasp, "sonarSimulator").
  qactor( sonardatasource, ctxsonaronrasp, "sonarHCSR04Support2021").
  qactor( datacleaner, ctxsonaronrasp, "dataCleaner").
  qactor( sonar, ctxsonaronrasp, "it.unibo.sonar.Sonar").
tracing.

</m></pre>
</td>
</tr>
 </tbody>
</table>
<h3>MockThermometer Configuration <em>ResourceAware</em></h3>
<table style="width:100%" border="1">

<tr>
<td style="width:50%">
 
Launch <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/sensor_executables/it.unibo.thermometer-1.0/it.unibo.thermometer-1.0/bin/it.unibo.thermometer.bat" target="web">it.unibo.thermometer.bat</a> situated in the directory <a href="https://github.com/noemival/ParkManagerService_2021/tree/main/it.unibo.parkManagerService/sensor_executables"target="web">sensor_executables</a> on Pc
 
</td>
<td>
<pre>
<m>
%====================================================================================
% thermometer description    
%====================================================================================
context(ctxthermometer, "localhost",  "TCP", "8015").
context(ctxparkingarea, "127.0.0.1",  "TCP", "8021").
 qactor( parkingmanager, ctxparkingarea, "external").
  qactor( thermometer, ctxthermometer, "it.unibo.thermometer.Thermometer").
  qactor( mockthermometer, ctxthermometer, "it.unibo.mockthermometer.Mockthermometer").
 </m></pre>
</td>
</tr>
 </tbody>
</table>
<h3>WeightSensorGui <em>UseMQTT</em></h3>
<table style="width:100%" border="1">

<tr>
<td style="width:50%">
Launch the   <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/sensor_executables/it.unibo.weightSensor-1.0/it.unibo.weightSensor-1.0/bin/it.unibo.weightSensor.bat"target="web">WeightSensorGui.kt</a> situated in the directory <a href="https://github.com/noemival/ParkManagerService_2021/tree/main/it.unibo.parkManagerService/sensor_executables"target="web">sensor_executables</a> on Pc
</td>
<td>
<pre>
<m>
%====================================================================================
% weightsensor description   
%====================================================================================
mqttBroker("localhost", "1883", "weightsensor/data").
context(ctxweightsensor, "localhost",  "TCP", "8018").
 qactor( weightsensor, ctxweightsensor, "it.unibo.weightsensor.Weightsensor").


</m></pre>
</td>
</tr>
 </tbody>
</table>

<h3>FanGui<em>ResourceAware</em></h3>
<table style="width:100%" border="1">

<tr>
<td style="width:50%">

Launch the  <a href="https://raw.githubusercontent.com/noemival/ParkManagerService_2021/main/it.unibo.parkManagerService/sensor_executables/it.unibo.fan-1.0/it.unibo.fan-1.0/bin/it.unibo.fan.bat" target="web">it.unibo.fan.bat </a> situated in the directory <a href="https://github.com/noemival/ParkManagerService_2021/tree/main/it.unibo.parkManagerService/sensor_executables"target="web">sensor_executables</a> on Pc
</td>
<td>
<pre>
<m>
%====================================================================================
% fan description   
%====================================================================================
context(ctxfan, "localhost",  "TCP", "8017").
 qactor( fan, ctxfan, "it.unibo.fan.Fan").

</m></pre>
</td>
</tr>
 </tbody>
</table>
<h3>WebApplication</h3>
<table style="width:100%" border="1">

<tr>
<td style="width:50%">

Launch the  <a href="https://github.com/noemival/ParkManagerService_2021/blob/main/it.unibo.parkManagerService/PMS_executable/bin/it.unibo.WebApplicationPms.bat" target="web">it.unibo.WebApplicationPms.bat </a> situated in the directory <a href="https://github.com/noemival/ParkManagerService_2021/tree/main/it.unibo.parkManagerService/PMS_executable"target="web">PMS_executable</a> on Pc
. <br>
To execute the webApplication is necessary to run a mqtt broker on localhost (e.g. mosquitto broker).
</td>
<td>
<pre>
<m>
%====================================================================================
% parkingarea description   
%====================================================================================
context(ctxparkingarea, "localhost",  "TCP", "8021").
 qactor( datacleaner, ctxparkingarea, "rx.dataCleaner").
  qactor( distancefilter, ctxparkingarea, "rx.distanceFilter").
  qactor( parkmanagerservice, ctxparkingarea, "it.unibo.parkmanagerservice.Parkmanagerservice").
  qactor( trolley, ctxparkingarea, "it.unibo.trolley.Trolley").
  qactor( outmanager, ctxparkingarea, "it.unibo.outmanager.Outmanager").
  qactor( fanmanager, ctxparkingarea, "it.unibo.fanmanager.Fanmanager").
  qactor( parkingmanager, ctxparkingarea, "it.unibo.parkingmanager.Parkingmanager").
  qactor( basicrobot, ctxparkingarea, "it.unibo.basicrobot.Basicrobot").
</m></pre>
</td>
</tr>
 </tbody>
</table>
 
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->
	      	
<br/><br/> 	
</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
By studentName email: antonio.iacobelli@studio.unibo.it  
<img src="./img/antonioIacobelli.jpg" alt="mbot" width="15%" height="15%">
</div> 
<br>
<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
By studentName email: noemi.valentini5@studio.unibo.it  
<img src="./img/noemiValentini.jpg" alt="mbot" width="15%" height="15%">
</div> 
</body>
</html>