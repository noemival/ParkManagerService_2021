 System  /*  -trace */ parkingarea           
//mqttBroker "localhost" : 1883 eventTopic "unibo/basicrobot"   		
Event outsonar : outsonar (O)
Dispatch outsonarocc : outsonarocc(G)
Dispatch outfree : outfree(free)
Event alarm : alarm(W)

Event weightsensor : weightsensor(W) 
Dispatch weight : weight (W)

  
   
Dispatch fanstart: fanstart(V)   
Dispatch fanstop : fanstop(V)

Event temperature :  temperature (T)  

  
Request carenter : carenter(C)
Reply receipt : receipt(I)


Request notifyIn : notifyIn(N)  
Reply informIn : informIn(S)

Request pickup : pickup(TOKENID)
Reply ok : ok(O)

Dispatch end : end(e)

Dispatch takecar : takecar(P)   
 
 
 
Event stateChangetrolley :  stateChangetrolley (V)
Event stateChangefan :  stateChangefan (V)
Dispatch warning : warning (V)

Dispatch temp : temp (V)
Dispatch trolleystop :  trolleystop(V)
Dispatch trolleyresume :  trolleyresume(V)
Dispatch trolleyState :  trolleyState(V)


Dispatch trolleycmd : trolleycmd(MOVETO)
Dispatch cmd       	: cmd(M)     
Dispatch trolleyEnd : end(V)   
Dispatch position : pos(P)   


Dispatch basicEnd       	: end(ARG)   
   
Dispatch moveok	: move( MOVESHORT )
Request step	: step( TIME )	
Reply   stepdone	: stepdone(V)  
Reply   stepfail	: stepfail(DURATION, CAUSE)
  
Dispatch obstacle  : obstacle( ARG ) 		//generated by distancefilter
Event  endall	   : endall( ARG )    
Event   info       : info( ARG ) 	    	//for external components, not coap-observed
Event  sonar       : sonar(DISTANCE,NAME)	//emitted by distancefilter
 
Context ctxparkingarea ip [host="localhost" port=8021]  


CodedQActor datacleaner    context ctxparkingarea className "rx.dataCleaner"  //NOT used with the virtualrobot
CodedQActor distancefilter context ctxparkingarea className "rx.distanceFilter"
  

QActor parkingservicegui context ctxparkingarea{

	[# 	var SLOTNUM = 0  
		var RequestAccepted = 1
		var TOKENID = ""
		var fileName = "Tokenid.txt"  
	    val file = java.io.File(fileName)
	    if(!file.exists()){
			file.createNewFile()
		}
	#]
	State s0 initial {
		
		println("parkingservicegui  |  start")
		
	} Goto requestToEnter
	
	State requestToEnter{
		
		println("parkingservicegui | requesttoenter ")
		request parkmanagerservice -m notifyIn : notifyIn(A)
		
	}Transition t0 whenReply informIn -> carEnter
	
	State carEnter{
		println("parkingservicegui | carEnter ")   
		delay 5000
		onMsg(informIn : informIn(S)){
		
		[# var SLOTNUM= payloadArg(0).toInt() #] 
		updateResource [#"slotNum($SLOTNUM)"#]
		println("parkingservicegui [carEnter] | receive SLOUTNUM = $SLOTNUM ")
		
		if[#SLOTNUM >0#]{
			
			delay 1000 //time required for the client to arrive at the parking-area
			println("parkingservicegui [carEnter] | send CARENTER ")
			request parkmanagerservice -m carenter : carenter ($SLOTNUM)
			forward weightsensor -m weight : weight (10000)
			} 
		else{
			println("parkingservicegui [carEnter] | all slots are occupied, try again later")
		}
		}
	}Transition t0  whenReply receipt -> saveTOKENID
	
	
	State saveTOKENID{
		
		println("parkingservicegui | saveTOKENID")
		onMsg(receipt : receipt(TOKENID)){
		[#	TOKENID = payloadArg(0).toString()
		#] 
		if[#!TOKENID.equals("no")#]	{
			[#file.writeText(TOKENID)  #]
			println("parkingservicegui [saveTOKENID] | receive TOKENID = $TOKENID")	
			}else{
				 println("parkingservicegui [saveTOKENID] | See you later") 
				
				}
			}	
	
	} Goto requestToEnter if[#TOKENID.equals("no")#] else wait


	State wait {
		
	println("parkingservicegui | wait")
	
	} Transition t0 whenTime 9000 -> requestPickup
	
	State requestPickup{
	
		println("parkingservicegui | requestPickup")	
		request parkmanagerservice -m pickup : pickup($TOKENID)
	
	} Transition t0 whenReply ok-> handlerResponsePickup
	
	State handlerResponsePickup{
		
		println("parkingservicegui| handlerResponsePickup")
		onMsg (ok: ok(O)){
		[#var  ok = payloadArg(0).toInt()#]
			
			if[#ok == 1#]{
				println("parkingservicegui [handlerResponsePickup] | pickup request has been accepted and processed $ok")
				[#RequestAccepted = 1#]
				forward outmanager -m takecar : takecar(P)
				forward outsonar -m takecar : takecar(P)
			}else{
			
			[#RequestAccepted =0#]
			println("parkingservicegui [handlerResponsePickup] |  wait for the outdoor area to be free")
			delay 4000
			}
		}
		
	}Goto requestPickup  if [# RequestAccepted == 0#] else end

	State end{
		
			forward parkmanagerservice -m end : end(e)
	}
}
	
QActor parkservicestatusgui context ctxparkingarea {
	
	State s0 initial {
		println("parkservicestatusgui | start")
	} Goto working
	State working{
		println("parkservicestatusgui | working")
		
	}
	Transition t0 	whenMsg warning -> handleWarning
					whenEvent alarm-> handleAlarm
					
	State handleAlarm{
		updateResource[#"alarm(a)"#]
		println("parkservicestatusgui [handleAlarm]| alarm outdoor vacated over DTFREE TIME")
		
	}Goto working
	
			State handleWarning{
			onMsg(warning: warning(V)){
			[# var warning= payloadArg(0)#]  
			if[#  warning == "TempOverMax"  #]{
				
				emit stateChangetrolley : stateChangetrolley(stop)
				//emit stateChangefan : stateChangefan(work) 
				
				println("parkservicestatusgui [handleAlarm]: send start command to fan and stop trolley ")
			}else{ 
				
				emit stateChangetrolley : stateChangetrolley(work)	
				emit stateChangefan : stateChangefan(stop)
								
				println("parkservicestatusgui  [handleAlarm]: send stop command to fan and resume trolley")
			}
		}
			
			
	}Goto working
	
	
	}
QActor outsonar context ctxparkingarea{
	
 	State s0 initial {
		println("outsonar | start")
	
	} Goto work
	
	State work{
			println("outsonar | work")
	}Transition t0 whenMsg outsonarocc ->handlemsg
	
	State handlemsg{
		println("outsonar | handlemsg")
		emit outsonar : outsonar (O)
		
		}Transition t0 whenTime 100 -> handlemsg
					   whenMsg 	takecar ->work 
		
}
QActor weightsensor context ctxparkingarea{
	
	State s0 initial {
		println("weightsensor |start")
			
	} Goto work
	
	State work{
		[#var WEIGHT=0#]
		
		println("weightsensor | work")
		onMsg( weight : weight(W) ){
			[# WEIGHT = payloadArg(0).toInt() #] 
			println ("weightsensor [work] | weight car = $WEIGHT")
			emit weightsensor : weightsensor ($WEIGHT)
			println("weightsensor [work] | emit event")
			delay 3000
		} 

	}Transition t0 whenMsg weight ->work	
}
	

QActor fan context ctxparkingarea{    
	
	State s0 initial {  
		println("fan | start")
	
	}Goto stopped   
	
	State stopped {
		println ("fan | stopped")
		updateResource [#"fan(stop)"#] 
		
	}Transition t0 whenMsg fanstart->working
				  
	State working {
		println("fan | working")
		updateResource [#"fan(work)"#]
	
	}Transition t0 whenMsg fanstop->stopped	
}


QActor thermometer context ctxparkingarea{
	State s0 initial {
		println("thermometer | starting ")
	
	} Goto work
	
	State work{
    	println("thermometer | work")
    	delay 10000
	   	emit temperature : temperature (30)
		delay 3000
		emit temperature : temperature (40)
		delay 5000   
		emit temperature : temperature (30)
	}    
}

QActor parkmanagerservice context ctxparkingarea{
	
	[# 	var SLOTNUM = 0
		var CARSLOTNUM = 0 
		var TOKENID = " "
		var INFREE = 1   
		var OUTFREE = 1
		var stateTrolley =""
	#]
	
	State s0  initial{
		
		println("parkmanagerservice | start")
	} Goto working 
	
	State working {
		
		println("parkmanagerservice | working")
		println("parkmanagerservice [working] | OUTDOOR = $OUTFREE")
		
		[#stateTrolley = utility.HandleData().getState("trolley")#]
		
		
	}Transition t0 	whenRequest notifyIn -> acceptIn
					whenRequest pickup -> acceptOut
					whenRequest carenter -> carenter
					whenEvent 	weightsensor -> handlemsgIn
					whenMsg 	outfree -> handlemsgOut
					whenMsg  	end -> theend	
	State handlemsgIn{
		onMsg(weightsensor: weightsensor(W)){
		[# var W = payloadArg(0).toInt() #] 
			
			if[#W>0#]{
				[#INFREE = 0 #]
				println("parkManagerService [handlemsgIn] | INDOOR occupied")
		
			}else {[#INFREE = 1#]
				println("parkManagerService [handlemsgIn] | INDOOR free")
				}
		}
	}Goto working
	
	State handlemsgOut{

		onMsg(outfree: outfree(W)){
			[# var O = payloadArg(0) #] 
			
			if[#O.equals("occ")#]{
				[#OUTFREE = 0 #]
				println("parkManagerService [handlemsgOut] | OUTDOOR occupied")
			}
			if[#O.equals("free")#] {
				[#OUTFREE = 1#]
				println("parkManagerService [handlemsgOut] | OUTDOOR free")
			}
		}
	
	}Goto working
			
	State acceptIn{
		println("parkManagerService | acceptIn")
		onMsg(notifyIn: notifyIn(N)){
				if	[# INFREE ==1 &&  !stateTrolley.equals("trolley(stopped)")#]{
					[# SLOTNUM = Slotnum.getSlotnum() #]
					replyTo notifyIn with informIn : informIn($SLOTNUM)
					[#Slotnum.uptadeSlotnum(SLOTNUM, false)#]
				}else {
					println("parkManagerService [acceptIn] | indoor-area occupied, the request could not be processed")
				}
		}
	}Transition t0	whenRequest carenter -> carenter
				 	whenRequest pickup -> acceptOut
					whenRequest notifyIn -> acceptIn
					whenEvent 	weightsensor -> handlemsgIn
					whenMsg 	outfree -> handlemsgOut
					whenMsg  	end -> theend	
					
			
	State carenter{
		println("parkManagerService | caraenter")
		onMsg(carenter : carenter(S)){
			
			[# SLOTNUM= payloadArg(0).toInt() #]
			
			if  [# SLOTNUM!= 0 && INFREE == 1#]{ 
				
				forward trolley -m trolleycmd : trolleycmd(moveToIn)
				[# var MOVETOSLOT = "moveToSlot".plus(SLOTNUM) #]
				println("parkManagerService [carenter] | send to trolley $MOVETOSLOT")
				forward trolley -m trolleycmd : trolleycmd($MOVETOSLOT)
				[# TOKENID=  Slotnum.generateTOKENID(SLOTNUM) #]
				println("parkManagerService [carenter] | send to client TOOKENID = $TOKENID")
				replyTo carenter with receipt : receipt($TOKENID)
				
			}else {
				
				println("parkManagerService [carenter] | send to trolley moveToHome")
				forward trolley -m trolleycmd : trolleycmd(moveToHome)
				replyTo carenter with receipt : receipt(no)//mando informazione al client
				[#Slotnum.uptadeSlotnum(SLOTNUM, true)#]
			}
			
		}
		
	}Goto working
	
	State acceptOut{
				
		[#stateTrolley = utility.HandleData().getState("trolley")#]
		
		println("parkManagerService | acceptOut ")
		onMsg(pickup : pickup(TOKENID)){ 
		
			if[#OUTFREE == 1 &&   !stateTrolley.equals("trolley(stopped)")#]{ 
		
				[#TOKENID= payloadArg(0).toString() #]
				println("parkManagerService [acceptOut] | receive TOKENID = $TOKENID")
				[# CARSLOTNUM = Slotnum.findSlot(TOKENID) #]
				println("parkManagerService [acceptOut] | receive CARSLOTNUM = $CARSLOTNUM")
				replyTo pickup with ok : ok(1)
				println("parkManagerService [acceptOut] | receive OUTFREE = $OUTFREE")
				[# Slotnum.uptadeSlotnum(CARSLOTNUM, true)
				var MOVETOSLOT = "moveToSlot".plus(CARSLOTNUM) #]
				forward trolley -m trolleycmd : trolleycmd($MOVETOSLOT)
				forward trolley -m trolleycmd :trolleycmd(moveToOut)
				delay 600
				
			}else{
			replyTo pickup with ok : ok(0)
			println("parkManagerService [acceptOut]: outdoor-area occupied, the request could not be processed")
			}
		
		}
		
	}Goto working
		
	State theend{
		
		forward trolley -m trolleycmd : trolleycmd(end)

	}
}
QActor outmanager context ctxparkingarea{
	[#	var start =  0L
		var difference = 0L
	
	#]
	State s0 initial{
		
		println ("outmanager | start")
		
	} Transition t0 whenEvent 	outsonar -> start
	
	State start{
		
		[# start = System.currentTimeMillis()#]
		println("outmanager [start] | start Timer ) ")
		
	}Goto work
		
	State work{
		
		[#difference = System.currentTimeMillis() - start#]
		println("outmanager [work] |  difference = $difference")
		if[#difference >= 1000L#]{
			println("outmanager [work]  | alarm event, time passed = $difference")
			emit alarm :alarm(a)
		}else {
			forward parkmanagerservice -m outfree : outfree(occ)
			println("outmanager [work]  | no alarm event ")
		} 

	} Transition t0 whenTime 300 ->work
					whenMsg takecar-> free
				
	State free {
		forward parkmanagerservice -m outfree : outfree(free)
		println("outmanager [free] | OUTDOORAREA FREE")
	}
}

QActor parkingmanager context ctxparkingarea {
	[#var fanIsStarted = 0
	  var robotIsActive = 1 
	  var stateTrolley = ""
	  var stateFan= ""
	  var start =  0L
	  var differenza = 0L
	  var temp1 = 0#]
	State s0 initial {
		println("parkingmanager | start") 
	} 
	Goto waiting
	State waiting{  
		println("parkingmanager | waiting") 
	}
	Transition t0 	whenEvent temperature-> handleTemperature
					whenEvent alarm-> handleAlarm
	
					
					
	State handleTemperature{
		onMsg(temperature : temperature(T)){
			[#  temp1= payloadArg(0).toInt()
				stateTrolley = utility.HandleData().getState("trolley")
				stateFan = utility.HandleData().getState("fan")
			#] 
				println("parkingmanager [handleTemperature] | state trolley = $stateTrolley state fan = $stateFan ")
				println("parkingmanager [handleTemperature] | temperature = $temp1 ")
					
				if[# temp1 > 35#]{
					forward parkservicestatusgui -m warning : warning (TempOverMax)
				}else{	
					 forward parkservicestatusgui -m warning : warning (TempUnderMax)
				}
		}
		
	}Transition t0  whenTime  2000 -> autoFan
					whenEvent temperature-> handleTemperature
					whenEvent stateChangetrolley -> handleTrolley
					whenEvent stateChangefan -> handleFan
					whenEvent alarm-> handleAlarm
	
	State handleTrolley{
		println("parkingmanager | handleTemperature troll = $temp1 ")
		
		onMsg(stateChangetrolley :stateChangetrolley(V) ){
			[#var stateT= payloadArg(0)#]
			if[# temp1 > 35 && !stateTrolley.equals("trolley(stopped)") && stateT.equals("stop")#]{
				println("parkingmanager | trolley stopped ")
				forward trolley -m trolleystop: trolleystop(V)
			}
			if[# temp1 < 35  &&  stateTrolley.equals("trolley(stopped)") && stateT.equals("work")#]{
				println("parkingmanager | trolley working ")
				forward trolley -m trolleyresume : trolleyresume(V)
				
			}      
			
		}
			
	}Transition t0 	whenTime  2000 -> autoFan
					whenEvent temperature-> handleTemperature
					whenEvent stateChangefan -> handleFan
					whenEvent alarm-> handleAlarm
	State handleFan{
		println("parkingmanager [handleFan] | temperature = $temp1 ")
		
		onMsg(stateChangefan :stateChangefan(V) ){
			[#var stateF= payloadArg(0)#]
			if[# temp1 > 35  && stateFan.equals("fan(stop)") && stateFan.equals("stop")#]{	
				
				println("parkingmanager [handleFan] | fan working ")
				forward fan -m 	fanstart : fanstart(V)
			}
			if[# temp1 < 35  && stateFan.equals("fan(work)") && stateFan.equals("work") #]{
				
				println("parkingmanager [handleFan] | fan stopped ")
				forward fan -m fanstop: fanstop(off)	
			}   
		
		}
			              
	}Transition t0  whenEvent temperature-> handleTemperature
					whenEvent stateChangetrolley -> handleTrolley
					whenEvent alarm-> handleAlarm
					
	State autoFan{
		
		if[# temp1 > 35  && stateFan.equals("fan(stop)")#] {	
			
			println("parkingmanager [autoFan] | fan working ")
			forward fan -m fanstart : fanstart(V)
		}
		if[# temp1 < 35  && stateFan.equals("fan(work)")  #] {
			
			println("parkingmanager [autoFan] | fan stopped ")
			forward fan -m fanstop : fanstop(V)
		}   
	
	}Transition t0  whenEvent temperature-> handleTemperature
					whenEvent stateChangetrolley -> handleTrolley
					whenEvent alarm-> handleAlarm

	
	State handleAlarm {
		println("parkingmanager [handleAlarm] |  OVER DTFREE TIME")
		emit alarm : alarm(V)
	}
	Transition t0 	whenTime 1000 -> autoFan
					whenEvent temperature-> handleTemperature
					whenEvent stateChangetrolley -> handleTrolley
					whenEvent stateChangefan -> handleFan
					whenEvent alarm-> handleAlarm
				
}


QActor trolley context ctxparkingarea{
	[#	val mapname     = "parkingMap0"  		  
  		var Myself      = myself    
  		var CurrentPlannedMove = ""   
  		var MOVE = ""
  		var terminate =  0
 		var home = 0 
 		var finishplannedMoves = 0
	 #]   	
	State s0 initial{
		println ("trolley | start")
		
		run itunibo.planner.plannerUtil.initAI()  
		println("&&&  trolley loads the parking map from the given file ...") 
		run itunibo.planner.plannerUtil.loadRoomMap("$mapname")  
		//Set the parking area ...
		run itunibo.planner.plannerUtil.showMap()   
     	run itunibo.planner.plannerUtil.showCurrentRobotState()
     	 
     	//run pathexecutil.register(Myself)   	
		  
	}
	
	
	Goto idle
	             
	State idle {
		println("trolley [idle]  | waiting......... ") 
		//updateResource [# "trolley(idle)" #]
	  
	} 	

	Transition t1  	 whenMsg     trolleycmd  -> working
					 whenMsg  trolleystop -> stopped
													
	State working{
		updateResource [# "trolley(working)" #]
		[#home = 0#]
		println("trolley | working") 
		
		onMsg( trolleycmd : trolleycmd(MOVE) ){
  
			[# MOVE =  "${payloadArg(0).toString()}" #] 
			println("Current move: $MOVE")
			
			if [# MOVE == "moveToIn" #] {
				println("trolley [working] | moveToIn ")
				run itunibo.planner.plannerUtil.planForGoal("6","0")
			}
			if [# MOVE == "moveToSlot1" #] {
				println("trolley [working] | moveToSlot1 ")
		 		run itunibo.planner.plannerUtil.planForGoal("4","1")
		 		
			}
			if [# MOVE == "moveToSlot2" #] {
				println("trolley [working] | moveToSlot2 ")
		 		run itunibo.planner.plannerUtil.planForGoal("1","1")
		 		
			}
			if [# MOVE == "moveToSlot3" #] {
				println("trolley [working] | moveToSlot3 ")
		 		run itunibo.planner.plannerUtil.planForGoal("4","2")
			}
			if [# MOVE == "moveToSlot4" #] {
				println("trolley [working] | moveToSlot4 ")
		 		run itunibo.planner.plannerUtil.planForGoal("1","2")
			}
			if [# MOVE == "moveToSlot5" #] {
				println("trolley [working] | moveToSlot5 ")
		 		run itunibo.planner.plannerUtil.planForGoal("4","3")
			}
			if [# MOVE == "moveToSlot6" #] {
				println("trolley [working] | moveToSlot6 ")
		 		run itunibo.planner.plannerUtil.planForGoal("1","3")
			}
			if [# MOVE == "moveToOut" #] {
				println("trolley [working] | moveToOut ")
				run itunibo.planner.plannerUtil.planForGoal("6","4")
			}
			if [#MOVE  == "moveToHome"#]{
				println("trolley [working] | $MOVE ")
				run itunibo.planner.plannerUtil.planForGoal("0","0")
				[# home =  1#]
			}
			if [# MOVE == "end"#]{
				println("trolley [working] | $MOVE ")
				run itunibo.planner.plannerUtil.planForGoal("0","0")
				[# terminate = 1#] 
			}
		}
	} Goto execPlannedMoves 
		
  	State execPlannedMoves{
  		updateResource [# "trolley(working)" #]
  		delay 400 
 		[#  CurrentPlannedMove = itunibo.planner.plannerUtil.getNextPlannedMove() #] 
 		println("trolley [execPlannedMoves] | execPlannedMoves = $CurrentPlannedMove")
	}
	Goto doMove if [# CurrentPlannedMove.length>0  #] else finishPlannedMoves //working
	
	State doMove{ 	
		
		if [# CurrentPlannedMove == "l"#]{
  			forward basicrobot -m cmd : cmd(l)
  		} 
  		if [#CurrentPlannedMove == "r"  #]{
  			forward basicrobot -m cmd : cmd(r)   
  		}   
  		if [#CurrentPlannedMove == "w"  #]{
  	 		forward basicrobot -m cmd : cmd(w)
  		} 
  		println("trolley | doMove")
  		run itunibo.planner.plannerUtil.updateMap("$CurrentPlannedMove")
  		run itunibo.planner.plannerUtil.showCurrentRobotState( )
 	}
	
	Transition t1   whenTime 100 -> execPlannedMoves
 					whenMsg  trolleycmd  and [#home == 1 && terminate == 0#]-> working
 					whenMsg  trolleystop -> stopped
 					
 	State stopped{
 		println("trolley | stopped")
 		updateResource [# "trolley(stopped)" #]
 		forward basicrobot -m cmd : cmd(h)
 	}
 	Transition t1 whenMsg trolleyresume -> execPlannedMoves 
 				  
 							
	State finishPlannedMoves{
		
		
 		[# var pos = itunibo.planner.plannerUtil.get_curPos().toString() #]
 		 println("trolley [finishPlannedMoves] | pos = $pos")
 		 
		if[#pos.equals("(6, 0)")#]{//update resources? 
			forward weightsensor -m weight : weight(0)
		}
		if[#pos.equals("(6, 4)")#]{
			forward outsonar -m outsonarocc : outsonarocc(0)
			forward parkingservicegui -m outsonarocc : outsonarocc(0)
		}
	
		println("trolley [finishPlannedMoves] | finish")
	
	}Goto end if [# terminate == 1 #] else idle
	
	State end{
		println("trolley | end")
		[#	var direction= itunibo.planner.plannerUtil.getDirection()
			
			if(direction == "leftDir"){
				forward("cmd", "cmd(l)" ,"basicrobot" )
				itunibo.planner.plannerUtil.updateMap( "l"  )
			}else{
				forward("cmd", "cmd(l)" ,"basicrobot" )
				itunibo.planner.plannerUtil.updateMap( "l"  ) 
				forward("cmd", "cmd(l)" ,"basicrobot" )
				itunibo.planner.plannerUtil.updateMap( "l"  ) 
			} 
		#]
			
		forward basicrobot -m end : end(V)   
	}					
}
   
	

QActor basicrobot context ctxparkingarea{
[#  
  var StepTime      = 0L 
  var StartTime     = 0L     
  var Duration      = 0L  
  var RobotType     = "" 
  var CurrentMove   = "moveUnknown"
#]     
	State s0 initial {     
		println("basicrobot | START")	 
 		//[# sysUtil.trace = true #]		//Equivalent to the -trace flag
 		 
 		[# sysUtil.waitUser("hello", 3000) #]
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		[# RobotType = unibo.robot.robotSupport.robotKind #]
        if[# RobotType != "virtual" #]{
	 		println("basicrobot | type=$RobotType attempts to activate the sonar pipe")	
	 		[#  //For real robots
				//delay( 1500 ) //give to the realsonar the time to start
	 			var robotsonar = context!!.hasActor("realsonar")  
	 			if( robotsonar != null ){ 
	 				println("basicrobot | WORKING WITH SONARS") 
	 				//ACTIVATE THE DATA SOURCE realsonar
	 				forward("sonarstart", "sonarstart(1)" ,"realsonar" ) 				
	 				//SET THE PIPE  
	 				robotsonar.
	 				subscribeLocalActor("datacleaner").
	 				subscribeLocalActor("distancefilter").
	 				subscribeLocalActor("basicrobot")		//in order to perceive obstacle
	 			}else{
	 				println("basicrobot | WARNING: realsonar NOT FOUND")
	 			}
	 		#]  
	 		
 		} 
		else{ //virtual
			[#  var robotsonar = context!!.hasActor("robotsonar") 
	 			if( robotsonar != null ){ 
	 				println("basicrobot | WORKING WITH VIRTUAL SONAR") 
	 				//ACTIVATE THE DATA SOURCE realsonar
	 				forward("sonarstart", "sonarstart(1)" ,"robotsonar" ) 				
	 				//WE DO NOT SET THE PIPE, since we don't have sonar data  to clean
	 			
	 				//robotsonar.
	 				//subscribeLocalActor("datacleaner").
	 				//subscribeLocalActor("distancefilter").
	 				//subscribeLocalActor("basicrobot")		
	 			}else{
	 				println("basicrobot | WARNING: robotsonar NOT FOUND")
	 			}
 
 			#] 
 		}
 		
	//	updateResource [# "basicrobot(start)" #]
 
		discardMsg Off  //WE want receive any msg 
	} 
	
	Goto work
	 
	State work{  
		println("basicrobot  | waiting .................. ")  
		
	}
	Transition t1   whenMsg    	cmd		-> exec
					whenRequest step	-> doStep			
					whenMsg		obstacle	-> handleObstacle  //in virtualrobot caused by the move w/s
				  	whenMsg    	end	-> endwork			   
	State exec{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){ 
  			//activate the motors  
			[# CurrentMove =  "${payloadArg(0)}" #] 
			println("CurrentMove = $CurrentMove")
		 	if [# CurrentMove == "w" #] {
				//delay 1000
				run unibo.robot.robotSupport.move( "w" ) 
				delay 400
				run unibo.robot.robotSupport.move( "h" )
			}else{
				run unibo.robot.robotSupport.move( "${payloadArg(0)}" )
				
				
			}
			if [# CurrentMove != "h" #] { 
				updateResource [# "$CurrentMove" #]
			}
		}
	 }  
	 
	Goto work      
	        
	State handleObstacle{   
	    run unibo.robot.robotSupport.move( "h" )
		println("basicrobot | handleObstacle CurrentMove=$CurrentMove")	
		printCurrentMessage
			//msg(obstacle,dispatch,distancefilter,basicrobot,obstacle(5),18)
		if[# CurrentMove == "w" #]{
 			
			  // collision Json      : emitted by the virtualrobot 
			  // obstacle(virtual)   : emitted by the virtualrobotSupport2021 when endmove=false
			  // obstacle(5)         : emitted by the distanceFilter
			  // obstacle(w)         : emitted by the basicrobot
			 
			//updateResource [# "obstacle(w)" #]
			//delay 300
			
			//println("COMPENSATEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE")
			run unibo.robot.robotSupport.move( "s" ) 
			delay 100 //loose the control ...
			run unibo.robot.robotSupport.move( "h" ) 
		
			//delay 1000	//give time
 		 
		} 	
	}
	Goto work

	
   	State doStep{ 
 		printCurrentMessage  
		onMsg( step : step( T ) ){  
			[#	StepTime = payloadArg(0).toLong() 	#]  
			updateResource [# "step(${StepTime})" #]
  		}  
        memoCurrentTime StartTime  
        println("basicrobot | doStep StepTime =$StepTime ")        
        run unibo.robot.robotSupport.move( "w" )  //moves a real robot forever
        
	}  
	Transition t0 	whenTimeVar StepTime  -> stepDone //stepPerhapsDone	//caused by p
					whenMsg  obstacle     -> stepFail		
        //whenMsg     cmd       -> execcmd
  	 
	State stepDone{   
 		run unibo.robot.robotSupport.move( "h" )  //stop the real robot already done
		println("basicrobot | stepDone")
		updateResource [# "stepDone($StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone(ok)
		//println("basicrobot | stepDone reply done")
  	}
	Goto work  
 
	State stepFail{  		    
		setDuration Duration from StartTime
		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		[# var TunedDuration = Duration;  
			TunedDuration = Duration * 5 / 6
		#]
		println("basicrobot | stepFail duration=$Duration TunedDuration=$TunedDuration")
			run unibo.robot.robotSupport.move( "s" )
			delayVar TunedDuration 
			run unibo.robot.robotSupport.move( "h" ) 
 		updateResource [# "stepFail($Duration)" #] 
 		//emit info : info( stepFail($Duration) )
 		replyTo step with stepfail : stepfail($Duration, obst)
    }
	Goto work
	
	State endwork{ 
		println("basicrobot | endwork")
		onMsg( end : end( V ) ){ 
			println("basicrobot | endwork")
			updateResource [# "basicrobot(end)" #]	 		
		}
 		emit endall : endall(normal) 
 		terminate 1
	}
	       
 }
 
 	
